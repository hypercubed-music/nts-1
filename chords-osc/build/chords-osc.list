
build/chords-osc.elf:     file format elf32-littlearm


Disassembly of section .text:

20000040 <_text_start>:
20000040:	4770      	bx	lr

20000042 <_hook_mute>:
20000042:	4770      	bx	lr

20000044 <_hook_value>:
20000044:	4770      	bx	lr
20000046:	4770      	bx	lr
20000048:	4770      	bx	lr
2000004a:	4770      	bx	lr
2000004c:	4770      	bx	lr

2000004e <_entry>:
2000004e:	4b10      	ldr	r3, [pc, #64]	; (20000090 <_entry+0x42>)
20000050:	4a10      	ldr	r2, [pc, #64]	; (20000094 <_entry+0x46>)
20000052:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
20000056:	4688      	mov	r8, r1
20000058:	4607      	mov	r7, r0
2000005a:	2100      	movs	r1, #0
2000005c:	4293      	cmp	r3, r2
2000005e:	d002      	beq.n	20000066 <_entry+0x18>
20000060:	f803 1f01 	strb.w	r1, [r3, #1]!
20000064:	e7fa      	b.n	2000005c <_entry+0xe>
20000066:	4b0c      	ldr	r3, [pc, #48]	; (20000098 <_entry+0x4a>)
20000068:	4c0c      	ldr	r4, [pc, #48]	; (2000009c <_entry+0x4e>)
2000006a:	1ae4      	subs	r4, r4, r3
2000006c:	10a4      	asrs	r4, r4, #2
2000006e:	2500      	movs	r5, #0
20000070:	461e      	mov	r6, r3
20000072:	42a5      	cmp	r5, r4
20000074:	d005      	beq.n	20000082 <_entry+0x34>
20000076:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
2000007a:	b103      	cbz	r3, 2000007e <_entry+0x30>
2000007c:	4798      	blx	r3
2000007e:	3501      	adds	r5, #1
20000080:	e7f7      	b.n	20000072 <_entry+0x24>
20000082:	4641      	mov	r1, r8
20000084:	4638      	mov	r0, r7
20000086:	f000 f80b 	bl	200000a0 <_hook_init>
2000008a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
2000008e:	bf00      	nop
20000090:	20001edf 	.word	0x20001edf
20000094:	20001f53 	.word	0x20001f53
20000098:	20000040 	.word	0x20000040
2000009c:	20000040 	.word	0x20000040

200000a0 <_hook_init>:
};

static State s_state; //Init a state variable

void OSC_INIT(uint32_t platform, uint32_t api)
{
200000a0:	4b06      	ldr	r3, [pc, #24]	; (200000bc <_hook_init+0x1c>)
    //Default values
    for (int i = 0; i < 12; i++) {
        s_state.w0[i] = 0.f;
200000a2:	2200      	movs	r2, #0
200000a4:	f103 0130 	add.w	r1, r3, #48	; 0x30
200000a8:	f843 2b04 	str.w	r2, [r3], #4
static State s_state; //Init a state variable

void OSC_INIT(uint32_t platform, uint32_t api)
{
    //Default values
    for (int i = 0; i < 12; i++) {
200000ac:	428b      	cmp	r3, r1
        s_state.w0[i] = 0.f;
        s_state.phase[i] = 0.f;
200000ae:	62da      	str	r2, [r3, #44]	; 0x2c
static State s_state; //Init a state variable

void OSC_INIT(uint32_t platform, uint32_t api)
{
    //Default values
    for (int i = 0; i < 12; i++) {
200000b0:	d1fa      	bne.n	200000a8 <_hook_init+0x8>
        s_state.w0[i] = 0.f;
        s_state.phase[i] = 0.f;
    }
    s_state.wave_type = 0.f;
200000b2:	4b03      	ldr	r3, [pc, #12]	; (200000c0 <_hook_init+0x20>)
200000b4:	2200      	movs	r2, #0
200000b6:	721a      	strb	r2, [r3, #8]
    s_state.key = 0;
200000b8:	729a      	strb	r2, [r3, #10]
200000ba:	4770      	bx	lr
200000bc:	20001ef0 	.word	0x20001ef0
200000c0:	20001ee0 	.word	0x20001ee0

200000c4 <_hook_cycle>:
}

void OSC_CYCLE(const user_osc_param_t * const params,
               int32_t *yn,
               const uint32_t frames)
{
200000c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    for (int i = 0; i < 4; i++) {
        s_state.notes[i] = extensions[(((params->pitch)>>8) + s_state.key) % 12][i];
200000c8:	4b16      	ldr	r3, [pc, #88]	; (20000124 <_hook_cycle+0x60>)
200000ca:	f8df 805c 	ldr.w	r8, [pc, #92]	; 20000128 <_hook_cycle+0x64>
200000ce:	f893 900a 	ldrb.w	r9, [r3, #10]
}

void OSC_CYCLE(const user_osc_param_t * const params,
               int32_t *yn,
               const uint32_t frames)
{
200000d2:	b09b      	sub	sp, #108	; 0x6c
    for (int i = 0; i < 4; i++) {
200000d4:	2600      	movs	r6, #0
        s_state.notes[i] = extensions[(((params->pitch)>>8) + s_state.key) % 12][i];
200000d6:	270c      	movs	r7, #12
200000d8:	8884      	ldrh	r4, [r0, #4]
200000da:	f8df e048 	ldr.w	lr, [pc, #72]	; 20000124 <_hook_cycle+0x60>
200000de:	eb09 2414 	add.w	r4, r9, r4, lsr #8
200000e2:	fb94 f5f7 	sdiv	r5, r4, r7
200000e6:	fb07 4415 	mls	r4, r7, r5, r4
200000ea:	eb06 0484 	add.w	r4, r6, r4, lsl #2
200000ee:	eb03 0c06 	add.w	ip, r3, r6

void OSC_CYCLE(const user_osc_param_t * const params,
               int32_t *yn,
               const uint32_t frames)
{
    for (int i = 0; i < 4; i++) {
200000f2:	3601      	adds	r6, #1
        s_state.notes[i] = extensions[(((params->pitch)>>8) + s_state.key) % 12][i];
200000f4:	f858 4024 	ldr.w	r4, [r8, r4, lsl #2]
200000f8:	f88c 400c 	strb.w	r4, [ip, #12]

void OSC_CYCLE(const user_osc_param_t * const params,
               int32_t *yn,
               const uint32_t frames)
{
    for (int i = 0; i < 4; i++) {
200000fc:	2e04      	cmp	r6, #4
200000fe:	d1eb      	bne.n	200000d8 <_hook_cycle+0x14>
        s_state.notes[i] = extensions[(((params->pitch)>>8) + s_state.key) % 12][i];
    }
    // Reset flags
    const uint8_t flags = s_state.flags;
    s_state.flags = k_flags_none;
20000100:	2400      	movs	r4, #0
{
    for (int i = 0; i < 4; i++) {
        s_state.notes[i] = extensions[(((params->pitch)>>8) + s_state.key) % 12][i];
    }
    // Reset flags
    const uint8_t flags = s_state.flags;
20000102:	f89e 7009 	ldrb.w	r7, [lr, #9]
    s_state.flags = k_flags_none;
20000106:	f88e 4009 	strb.w	r4, [lr, #9]

    float w0[12];
    float phase[12];
    switch (s_state.extension) {
2000010a:	f89e 400b 	ldrb.w	r4, [lr, #11]
2000010e:	2c04      	cmp	r4, #4
20000110:	f200 86c4 	bhi.w	20000e9c <_hook_cycle+0xdd8>
20000114:	e8df f014 	tbh	[pc, r4, lsl #1]
20000118:	01f2000a 	.word	0x01f2000a
2000011c:	0520037e 	.word	0x0520037e
20000120:	0520      	.short	0x0520
20000122:	bf00      	nop
20000124:	20001ee0 	.word	0x20001ee0
20000128:	20001e1c 	.word	0x20001e1c
        case 0:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
2000012c:	8885      	ldrh	r5, [r0, #4]
2000012e:	7b1c      	ldrb	r4, [r3, #12]
20000130:	ed93 4a1c 	vldr	s8, [r3, #112]	; 0x70
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000134:	4ee7      	ldr	r6, [pc, #924]	; (200004d4 <_hook_cycle+0x410>)

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000136:	eddf 4ae8 	vldr	s9, [pc, #928]	; 200004d8 <_hook_cycle+0x414>
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
2000013a:	ed9f 5ae8 	vldr	s10, [pc, #928]	; 200004dc <_hook_cycle+0x418>
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.8f);
2000013e:	ed9f 3ae8 	vldr	s6, [pc, #928]	; 200004e0 <_hook_cycle+0x41c>

    float w0[12];
    float phase[12];
    switch (s_state.extension) {
        case 0:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
20000142:	eb04 2415 	add.w	r4, r4, r5, lsr #8
20000146:	b2ed      	uxtb	r5, r5
20000148:	ee07 5a10 	vmov	s14, r5
2000014c:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
20000150:	b2e4      	uxtb	r4, r4
20000152:	ee36 7a04 	vadd.f32	s14, s12, s8

/** Clip upper bound of unsigned integer x to m (inclusive)
 */
static inline __attribute__((optimize("Ofast"), always_inline))
uint32_t clipmaxu32(const uint32_t x, const uint32_t m) {
  return (((x)>=m)?m:(x));
20000156:	2c96      	cmp	r4, #150	; 0x96
20000158:	eebc 7ac7 	vcvt.u32.f32	s14, s14
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.8f);
2000015c:	ee24 3a03 	vmul.f32	s6, s8, s6

    float w0[12];
    float phase[12];
    switch (s_state.extension) {
        case 0:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
20000160:	ed8d 7a01 	vstr	s14, [sp, #4]
20000164:	f89d 5004 	ldrb.w	r5, [sp, #4]
20000168:	ee07 5a10 	vmov	s14, r5
2000016c:	bf94      	ite	ls
2000016e:	4625      	movls	r5, r4
20000170:	2597      	movhi	r5, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000172:	eb06 0585 	add.w	r5, r6, r5, lsl #2
20000176:	edd5 6a00 	vldr	s13, [r5]
   * @param note Note in [0-151] range, mod in [0-255] range.
   * @return     Corresponding 0-1 phase increment in floating point.
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
2000017a:	1c65      	adds	r5, r4, #1
2000017c:	b2ed      	uxtb	r5, r5
2000017e:	2d96      	cmp	r5, #150	; 0x96
20000180:	bf94      	ite	ls
20000182:	46ae      	movls	lr, r5
20000184:	f04f 0e97 	movhi.w	lr, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000188:	eb06 0e8e 	add.w	lr, r6, lr, lsl #2
2000018c:	edde 5a00 	vldr	s11, [lr]
20000190:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
20000194:	ee75 5ae6 	vsub.f32	s11, s11, s13
20000198:	ee27 7a24 	vmul.f32	s14, s14, s9
2000019c:	eef0 3a66 	vmov.f32	s7, s13
200001a0:	eee7 3a25 	vfma.f32	s7, s14, s11

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
200001a4:	ed9f 7acf 	vldr	s14, [pc, #828]	; 200004e4 <_hook_cycle+0x420>
200001a8:	eef4 3ac7 	vcmpe.f32	s7, s14
200001ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200001b0:	bfa8      	it	ge
200001b2:	eef0 3a47 	vmovge.f32	s7, s14
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
200001b6:	ee63 3a85 	vmul.f32	s7, s7, s10

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200001ba:	eef0 2a66 	vmov.f32	s5, s13
200001be:	edc3 3a04 	vstr	s7, [r3, #16]
200001c2:	edcd 3a02 	vstr	s7, [sp, #8]
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.8f);
200001c6:	ee76 3a03 	vadd.f32	s7, s12, s6
200001ca:	eeb0 2a66 	vmov.f32	s4, s13
200001ce:	eefc 3ae3 	vcvt.u32.f32	s7, s7
200001d2:	eef0 1a66 	vmov.f32	s3, s13
200001d6:	edcd 3a01 	vstr	s7, [sp, #4]
200001da:	f89d e004 	ldrb.w	lr, [sp, #4]
200001de:	ee03 ea90 	vmov	s7, lr
200001e2:	eef8 3ae3 	vcvt.f32.s32	s7, s7
200001e6:	eeb0 1a66 	vmov.f32	s2, s13
200001ea:	ee63 3aa4 	vmul.f32	s7, s7, s9
200001ee:	eef0 0a66 	vmov.f32	s1, s13
200001f2:	eee3 2aa5 	vfma.f32	s5, s7, s11
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.1f);
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.1f);
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.2f);
            w0[8] = s_state.w0[8] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.4f);
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.6f);
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.8f);
200001f6:	ee36 3a43 	vsub.f32	s6, s12, s6

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
200001fa:	eef4 2ac7 	vcmpe.f32	s5, s14
200001fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000202:	eef0 3a62 	vmov.f32	s7, s5
    float phase[12];
    switch (s_state.extension) {
        case 0:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.8f);
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
20000206:	eddf 2ab8 	vldr	s5, [pc, #736]	; 200004e8 <_hook_cycle+0x424>

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
2000020a:	bfa8      	it	ge
2000020c:	eef0 3a47 	vmovge.f32	s7, s14
20000210:	ee63 3a85 	vmul.f32	s7, s7, s10
20000214:	ee64 2a22 	vmul.f32	s5, s8, s5
    float w0[12];
    float phase[12];
    switch (s_state.extension) {
        case 0:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.8f);
20000218:	edc3 3a05 	vstr	s7, [r3, #20]
2000021c:	edcd 3a03 	vstr	s7, [sp, #12]
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
20000220:	ee76 3a22 	vadd.f32	s7, s12, s5
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.2f);
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.1f);
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.1f);
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.2f);
            w0[8] = s_state.w0[8] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.4f);
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.6f);
20000224:	ee76 2a62 	vsub.f32	s5, s12, s5
    float phase[12];
    switch (s_state.extension) {
        case 0:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.8f);
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
20000228:	eefc 3ae3 	vcvt.u32.f32	s7, s7
2000022c:	edcd 3a01 	vstr	s7, [sp, #4]
20000230:	f89d e004 	ldrb.w	lr, [sp, #4]
20000234:	ee03 ea90 	vmov	s7, lr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000238:	eef8 3ae3 	vcvt.f32.s32	s7, s7
2000023c:	ee63 3aa4 	vmul.f32	s7, s7, s9
20000240:	eea3 2aa5 	vfma.f32	s4, s7, s11

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000244:	eeb4 2ac7 	vcmpe.f32	s4, s14
20000248:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
2000024c:	eef0 3a42 	vmov.f32	s7, s4
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.4f);
20000250:	ed9f 2aa6 	vldr	s4, [pc, #664]	; 200004ec <_hook_cycle+0x428>

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000254:	bfa8      	it	ge
20000256:	eef0 3a47 	vmovge.f32	s7, s14
2000025a:	ee63 3a85 	vmul.f32	s7, s7, s10
2000025e:	ee24 2a02 	vmul.f32	s4, s8, s4
    float phase[12];
    switch (s_state.extension) {
        case 0:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.8f);
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
20000262:	edc3 3a06 	vstr	s7, [r3, #24]
20000266:	edcd 3a04 	vstr	s7, [sp, #16]
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.4f);
2000026a:	ee76 3a02 	vadd.f32	s7, s12, s4
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.2f);
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.1f);
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.1f);
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.2f);
            w0[8] = s_state.w0[8] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.4f);
2000026e:	ee36 2a42 	vsub.f32	s4, s12, s4
    switch (s_state.extension) {
        case 0:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.8f);
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.4f);
20000272:	eefc 3ae3 	vcvt.u32.f32	s7, s7
20000276:	edcd 3a01 	vstr	s7, [sp, #4]
2000027a:	f89d e004 	ldrb.w	lr, [sp, #4]
2000027e:	ee03 ea90 	vmov	s7, lr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000282:	eef8 3ae3 	vcvt.f32.s32	s7, s7
20000286:	ee63 3aa4 	vmul.f32	s7, s7, s9
2000028a:	eee3 1aa5 	vfma.f32	s3, s7, s11

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
2000028e:	eef4 1ac7 	vcmpe.f32	s3, s14
20000292:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000296:	eef0 3a61 	vmov.f32	s7, s3
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.2f);
2000029a:	eddf 1a95 	vldr	s3, [pc, #596]	; 200004f0 <_hook_cycle+0x42c>

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
2000029e:	bfa8      	it	ge
200002a0:	eef0 3a47 	vmovge.f32	s7, s14
200002a4:	ee63 3a85 	vmul.f32	s7, s7, s10
200002a8:	ee64 1a21 	vmul.f32	s3, s8, s3
    switch (s_state.extension) {
        case 0:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.8f);
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.4f);
200002ac:	edc3 3a07 	vstr	s7, [r3, #28]
200002b0:	edcd 3a05 	vstr	s7, [sp, #20]
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.2f);
200002b4:	ee76 3a21 	vadd.f32	s7, s12, s3
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.1f);
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.1f);
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.2f);
200002b8:	ee76 1a61 	vsub.f32	s3, s12, s3
        case 0:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.8f);
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.4f);
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.2f);
200002bc:	eefc 3ae3 	vcvt.u32.f32	s7, s7
200002c0:	edcd 3a01 	vstr	s7, [sp, #4]
200002c4:	f89d e004 	ldrb.w	lr, [sp, #4]
200002c8:	ee03 ea90 	vmov	s7, lr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200002cc:	eef8 3ae3 	vcvt.f32.s32	s7, s7
200002d0:	ee63 3aa4 	vmul.f32	s7, s7, s9
200002d4:	eea3 1aa5 	vfma.f32	s2, s7, s11

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
200002d8:	eeb4 1ac7 	vcmpe.f32	s2, s14
200002dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200002e0:	eef0 3a41 	vmov.f32	s7, s2
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.1f);
200002e4:	ed9f 1a83 	vldr	s2, [pc, #524]	; 200004f4 <_hook_cycle+0x430>

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
200002e8:	bfa8      	it	ge
200002ea:	eef0 3a47 	vmovge.f32	s7, s14
200002ee:	ee63 3a85 	vmul.f32	s7, s7, s10
200002f2:	ee24 1a01 	vmul.f32	s2, s8, s2
        case 0:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.8f);
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.4f);
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.2f);
200002f6:	edc3 3a08 	vstr	s7, [r3, #32]
200002fa:	edcd 3a06 	vstr	s7, [sp, #24]
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.1f);
200002fe:	ee76 3a01 	vadd.f32	s7, s12, s2
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.1f);
20000302:	ee36 1a41 	vsub.f32	s2, s12, s2
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.8f);
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.4f);
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.2f);
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.1f);
20000306:	eefc 3ae3 	vcvt.u32.f32	s7, s7
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.1f);
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.2f);
            w0[8] = s_state.w0[8] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.4f);
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.6f);
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.8f);
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
2000030a:	ee36 6a44 	vsub.f32	s12, s12, s8
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.8f);
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.4f);
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.2f);
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.1f);
2000030e:	edcd 3a01 	vstr	s7, [sp, #4]
20000312:	f89d e004 	ldrb.w	lr, [sp, #4]
20000316:	ee03 ea90 	vmov	s7, lr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
2000031a:	eef8 3ae3 	vcvt.f32.s32	s7, s7
2000031e:	ee63 3aa4 	vmul.f32	s7, s7, s9
20000322:	eee3 0aa5 	vfma.f32	s1, s7, s11

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000326:	eef4 0ac7 	vcmpe.f32	s1, s14
2000032a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
2000032e:	eef0 3a60 	vmov.f32	s7, s1

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000332:	bfa8      	it	ge
20000334:	eef0 3a47 	vmovge.f32	s7, s14
20000338:	ee63 3a85 	vmul.f32	s7, s7, s10
2000033c:	edc3 3a09 	vstr	s7, [r3, #36]	; 0x24
20000340:	edcd 3a07 	vstr	s7, [sp, #28]
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.1f);
20000344:	eefc 3ac1 	vcvt.u32.f32	s7, s2

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000348:	eeb0 1a66 	vmov.f32	s2, s13
2000034c:	edcd 3a01 	vstr	s7, [sp, #4]
20000350:	f89d e004 	ldrb.w	lr, [sp, #4]
20000354:	ee03 ea90 	vmov	s7, lr
20000358:	eef8 3ae3 	vcvt.f32.s32	s7, s7
2000035c:	ee63 3aa4 	vmul.f32	s7, s7, s9
20000360:	eea5 1aa3 	vfma.f32	s2, s11, s7

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000364:	eeb4 1ac7 	vcmpe.f32	s2, s14
20000368:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
2000036c:	eef0 3a41 	vmov.f32	s7, s2

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000370:	bfa8      	it	ge
20000372:	eef0 3a47 	vmovge.f32	s7, s14
20000376:	ee63 3a85 	vmul.f32	s7, s7, s10
2000037a:	edc3 3a0a 	vstr	s7, [r3, #40]	; 0x28
2000037e:	edcd 3a08 	vstr	s7, [sp, #32]
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.2f);
20000382:	eefc 3ae1 	vcvt.u32.f32	s7, s3

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000386:	eef0 1a66 	vmov.f32	s3, s13
2000038a:	edcd 3a01 	vstr	s7, [sp, #4]
2000038e:	f89d e004 	ldrb.w	lr, [sp, #4]
20000392:	ee03 ea90 	vmov	s7, lr
20000396:	eef8 3ae3 	vcvt.f32.s32	s7, s7
2000039a:	ee63 3aa4 	vmul.f32	s7, s7, s9
2000039e:	eee5 1aa3 	vfma.f32	s3, s11, s7

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
200003a2:	eef4 1ac7 	vcmpe.f32	s3, s14
200003a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200003aa:	eef0 3a61 	vmov.f32	s7, s3

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
200003ae:	bfa8      	it	ge
200003b0:	eef0 3a47 	vmovge.f32	s7, s14
200003b4:	ee63 3a85 	vmul.f32	s7, s7, s10
200003b8:	edc3 3a0b 	vstr	s7, [r3, #44]	; 0x2c
200003bc:	edcd 3a09 	vstr	s7, [sp, #36]	; 0x24
            w0[8] = s_state.w0[8] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.4f);
200003c0:	eefc 3ac2 	vcvt.u32.f32	s7, s4

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200003c4:	eeb0 2a66 	vmov.f32	s4, s13
200003c8:	edcd 3a01 	vstr	s7, [sp, #4]
200003cc:	f89d e004 	ldrb.w	lr, [sp, #4]
200003d0:	ee03 ea90 	vmov	s7, lr
200003d4:	eef8 3ae3 	vcvt.f32.s32	s7, s7
200003d8:	ee63 3aa4 	vmul.f32	s7, s7, s9
200003dc:	eea5 2aa3 	vfma.f32	s4, s11, s7

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
200003e0:	eeb4 2ac7 	vcmpe.f32	s4, s14
200003e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200003e8:	eef0 3a42 	vmov.f32	s7, s4

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
200003ec:	bfa8      	it	ge
200003ee:	eef0 3a47 	vmovge.f32	s7, s14
200003f2:	ee63 3a85 	vmul.f32	s7, s7, s10
200003f6:	edc3 3a0c 	vstr	s7, [r3, #48]	; 0x30
200003fa:	edcd 3a0a 	vstr	s7, [sp, #40]	; 0x28
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.6f);
200003fe:	eefc 3ae2 	vcvt.u32.f32	s7, s5

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000402:	eef0 2a66 	vmov.f32	s5, s13
20000406:	edcd 3a01 	vstr	s7, [sp, #4]
2000040a:	f89d e004 	ldrb.w	lr, [sp, #4]
2000040e:	ee03 ea90 	vmov	s7, lr
20000412:	eef8 3ae3 	vcvt.f32.s32	s7, s7
20000416:	f8df e0e0 	ldr.w	lr, [pc, #224]	; 200004f8 <_hook_cycle+0x434>
2000041a:	ee63 3aa4 	vmul.f32	s7, s7, s9
2000041e:	eee5 2aa3 	vfma.f32	s5, s11, s7

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000422:	eef4 2ac7 	vcmpe.f32	s5, s14
20000426:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
2000042a:	eef0 3a62 	vmov.f32	s7, s5

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
2000042e:	bfa8      	it	ge
20000430:	eef0 3a47 	vmovge.f32	s7, s14
20000434:	ee63 3a85 	vmul.f32	s7, s7, s10
20000438:	edce 3a0d 	vstr	s7, [lr, #52]	; 0x34
2000043c:	edcd 3a0b 	vstr	s7, [sp, #44]	; 0x2c
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.8f);
20000440:	eefc 3ac3 	vcvt.u32.f32	s7, s6
20000444:	edcd 3a01 	vstr	s7, [sp, #4]
20000448:	f89d c004 	ldrb.w	ip, [sp, #4]
2000044c:	ee03 ca90 	vmov	s7, ip

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000450:	eef8 3ae3 	vcvt.f32.s32	s7, s7
20000454:	ee63 3aa4 	vmul.f32	s7, s7, s9
20000458:	eee5 6aa3 	vfma.f32	s13, s11, s7

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
2000045c:	eef4 6ac7 	vcmpe.f32	s13, s14
20000460:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000464:	bfa8      	it	ge
20000466:	eef0 6a47 	vmovge.f32	s13, s14
2000046a:	ee66 6a85 	vmul.f32	s13, s13, s10
2000046e:	2c97      	cmp	r4, #151	; 0x97
20000470:	edce 6a0e 	vstr	s13, [lr, #56]	; 0x38
20000474:	edcd 6a0c 	vstr	s13, [sp, #48]	; 0x30
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
20000478:	eefc 6ac6 	vcvt.u32.f32	s13, s12
2000047c:	bf28      	it	cs
2000047e:	2497      	movcs	r4, #151	; 0x97
20000480:	edcd 6a01 	vstr	s13, [sp, #4]
20000484:	f89d c004 	ldrb.w	ip, [sp, #4]
20000488:	2d97      	cmp	r5, #151	; 0x97
2000048a:	bf28      	it	cs
2000048c:	2597      	movcs	r5, #151	; 0x97
2000048e:	ee06 ca90 	vmov	s13, ip
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000492:	eb06 0484 	add.w	r4, r6, r4, lsl #2
20000496:	eb06 0685 	add.w	r6, r6, r5, lsl #2
2000049a:	ed94 6a00 	vldr	s12, [r4]

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
2000049e:	edd6 5a00 	vldr	s11, [r6]
200004a2:	eef8 6ae6 	vcvt.f32.s32	s13, s13
200004a6:	ee75 5ac6 	vsub.f32	s11, s11, s12
200004aa:	ee66 4aa4 	vmul.f32	s9, s13, s9
200004ae:	eef0 6a46 	vmov.f32	s13, s12
200004b2:	eee5 6aa4 	vfma.f32	s13, s11, s9

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
200004b6:	eef4 6ac7 	vcmpe.f32	s13, s14
200004ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200004be:	bfb8      	it	lt
200004c0:	eeb0 7a66 	vmovlt.f32	s14, s13
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
200004c4:	ee27 7a05 	vmul.f32	s14, s14, s10
200004c8:	ed8e 7a0f 	vstr	s14, [lr, #60]	; 0x3c
200004cc:	ed8d 7a0d 	vstr	s14, [sp, #52]	; 0x34
            break;
200004d0:	f000 bce4 	b.w	20000e9c <_hook_cycle+0xdd8>
200004d4:	0800f100 	.word	0x0800f100
200004d8:	3b808081 	.word	0x3b808081
200004dc:	37aec33e 	.word	0x37aec33e
200004e0:	3f4ccccd 	.word	0x3f4ccccd
200004e4:	46b8ff49 	.word	0x46b8ff49
200004e8:	3f19999a 	.word	0x3f19999a
200004ec:	3ecccccd 	.word	0x3ecccccd
200004f0:	3e4ccccd 	.word	0x3e4ccccd
200004f4:	3dcccccd 	.word	0x3dcccccd
200004f8:	20001ee0 	.word	0x20001ee0
        case 1:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
200004fc:	8884      	ldrh	r4, [r0, #4]
200004fe:	ed93 1a1c 	vldr	s2, [r3, #112]	; 0x70
20000502:	7b1d      	ldrb	r5, [r3, #12]
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000504:	4ebc      	ldr	r6, [pc, #752]	; (200007f8 <_hook_cycle+0x734>)
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);
20000506:	eddf 1ac0 	vldr	s3, [pc, #768]	; 20000808 <_hook_cycle+0x744>

    return f * k_samplerate_recipf;
2000050a:	eddf 5ac0 	vldr	s11, [pc, #768]	; 2000080c <_hook_cycle+0x748>
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
2000050e:	eddf 2abb 	vldr	s5, [pc, #748]	; 200007fc <_hook_cycle+0x738>
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.3f);
20000512:	ed9f 4abb 	vldr	s8, [pc, #748]	; 20000800 <_hook_cycle+0x73c>
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.6f);
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.8f);
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
            break;
        case 1:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
20000516:	ea4f 2c14 	mov.w	ip, r4, lsr #8
2000051a:	b2e4      	uxtb	r4, r4
2000051c:	ee07 4a10 	vmov	s14, r4
20000520:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
20000524:	4465      	add	r5, ip
20000526:	ee36 7a01 	vadd.f32	s14, s12, s2
2000052a:	b2ed      	uxtb	r5, r5
2000052c:	eebc 7ac7 	vcvt.u32.f32	s14, s14
20000530:	2d96      	cmp	r5, #150	; 0x96
20000532:	ed8d 7a01 	vstr	s14, [sp, #4]
20000536:	f89d 4004 	ldrb.w	r4, [sp, #4]
2000053a:	ed9f 7ab5 	vldr	s14, [pc, #724]	; 20000810 <_hook_cycle+0x74c>
   * @param note Note in [0-151] range, mod in [0-255] range.
   * @return     Corresponding 0-1 phase increment in floating point.
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
2000053e:	f105 0e01 	add.w	lr, r5, #1
20000542:	fa5f fe8e 	uxtb.w	lr, lr
20000546:	ee05 4a10 	vmov	s10, r4
2000054a:	bf94      	ite	ls
2000054c:	462c      	movls	r4, r5
2000054e:	2497      	movhi	r4, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000550:	eb06 0484 	add.w	r4, r6, r4, lsl #2
20000554:	f1be 0f96 	cmp.w	lr, #150	; 0x96
20000558:	edd4 6a00 	vldr	s13, [r4]
2000055c:	bf94      	ite	ls
2000055e:	4674      	movls	r4, lr
20000560:	2497      	movhi	r4, #151	; 0x97
20000562:	eb06 0484 	add.w	r4, r6, r4, lsl #2

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000566:	ed94 2a00 	vldr	s4, [r4]
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);
2000056a:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
2000056e:	ee32 2a66 	vsub.f32	s4, s4, s13
20000572:	ee25 5a21 	vmul.f32	s10, s10, s3
20000576:	eef0 4a66 	vmov.f32	s9, s13
2000057a:	eee5 4a02 	vfma.f32	s9, s10, s4
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
2000057e:	ee61 2a22 	vmul.f32	s5, s2, s5

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000582:	eef4 4ac7 	vcmpe.f32	s9, s14
20000586:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
2000058a:	bfa8      	it	ge
2000058c:	eef0 4a47 	vmovge.f32	s9, s14

    return f * k_samplerate_recipf;
20000590:	ee64 4aa5 	vmul.f32	s9, s9, s11
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.3f);
20000594:	ee21 4a04 	vmul.f32	s8, s2, s8
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.6f);
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.8f);
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
            break;
        case 1:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
20000598:	edc3 4a04 	vstr	s9, [r3, #16]
2000059c:	edcd 4a02 	vstr	s9, [sp, #8]
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
200005a0:	ee76 4a22 	vadd.f32	s9, s12, s5
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.3f);
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.3f);
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.6f);
200005a4:	ee76 2a62 	vsub.f32	s5, s12, s5
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.8f);
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
            break;
        case 1:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
200005a8:	eefc 4ae4 	vcvt.u32.f32	s9, s9
200005ac:	edcd 4a01 	vstr	s9, [sp, #4]
200005b0:	f89d 4004 	ldrb.w	r4, [sp, #4]
200005b4:	ee03 4a10 	vmov	s6, r4
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);
200005b8:	eeb8 3ac3 	vcvt.f32.s32	s6, s6

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200005bc:	eef0 4a66 	vmov.f32	s9, s13
200005c0:	ee23 3a21 	vmul.f32	s6, s6, s3
200005c4:	eee3 4a02 	vfma.f32	s9, s6, s4

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
200005c8:	eef4 4ac7 	vcmpe.f32	s9, s14
200005cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200005d0:	bfa8      	it	ge
200005d2:	eef0 4a47 	vmovge.f32	s9, s14

    return f * k_samplerate_recipf;
200005d6:	ee64 4aa5 	vmul.f32	s9, s9, s11
200005da:	edc3 4a05 	vstr	s9, [r3, #20]
200005de:	edcd 4a03 	vstr	s9, [sp, #12]
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.3f);
200005e2:	ee76 4a04 	vadd.f32	s9, s12, s8
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.3f);
200005e6:	ee36 4a44 	vsub.f32	s8, s12, s8
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
            break;
        case 1:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.3f);
200005ea:	eefc 4ae4 	vcvt.u32.f32	s9, s9
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.3f);
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.6f);
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
200005ee:	ee36 6a41 	vsub.f32	s12, s12, s2
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
            break;
        case 1:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.3f);
200005f2:	edcd 4a01 	vstr	s9, [sp, #4]
200005f6:	f89d 4004 	ldrb.w	r4, [sp, #4]
200005fa:	ee03 4a90 	vmov	s7, r4
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);
200005fe:	eef8 3ae3 	vcvt.f32.s32	s7, s7

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000602:	eef0 4a66 	vmov.f32	s9, s13
20000606:	ee63 3aa1 	vmul.f32	s7, s7, s3
2000060a:	eee3 4a82 	vfma.f32	s9, s7, s4

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
2000060e:	eef4 4ac7 	vcmpe.f32	s9, s14
20000612:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000616:	bfa8      	it	ge
20000618:	eef0 4a47 	vmovge.f32	s9, s14

    return f * k_samplerate_recipf;
2000061c:	ee64 4aa5 	vmul.f32	s9, s9, s11
20000620:	edc3 4a06 	vstr	s9, [r3, #24]
20000624:	edcd 4a04 	vstr	s9, [sp, #16]
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.3f);
20000628:	eefc 4ac4 	vcvt.u32.f32	s9, s8
2000062c:	edcd 4a01 	vstr	s9, [sp, #4]
20000630:	f89d 4004 	ldrb.w	r4, [sp, #4]
20000634:	ee04 4a10 	vmov	s8, r4
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);
20000638:	eeb8 4ac4 	vcvt.f32.s32	s8, s8

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
2000063c:	eef0 4a66 	vmov.f32	s9, s13
20000640:	ee24 4a21 	vmul.f32	s8, s8, s3
20000644:	eee4 4a02 	vfma.f32	s9, s8, s4

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000648:	eef4 4ac7 	vcmpe.f32	s9, s14
2000064c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000650:	bfa8      	it	ge
20000652:	eef0 4a47 	vmovge.f32	s9, s14

    return f * k_samplerate_recipf;
20000656:	ee64 4aa5 	vmul.f32	s9, s9, s11
2000065a:	edc3 4a07 	vstr	s9, [r3, #28]
2000065e:	edcd 4a05 	vstr	s9, [sp, #20]
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.6f);
20000662:	eefc 4ae2 	vcvt.u32.f32	s9, s5
20000666:	edcd 4a01 	vstr	s9, [sp, #4]
2000066a:	f89d 4004 	ldrb.w	r4, [sp, #4]
2000066e:	ee04 4a90 	vmov	s9, r4
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);
20000672:	eef8 4ae4 	vcvt.f32.s32	s9, s9
20000676:	ee64 4aa1 	vmul.f32	s9, s9, s3

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
2000067a:	eee4 6a82 	vfma.f32	s13, s9, s4

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
2000067e:	eef4 6ac7 	vcmpe.f32	s13, s14
20000682:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000686:	bfa8      	it	ge
20000688:	eef0 6a47 	vmovge.f32	s13, s14

    return f * k_samplerate_recipf;
2000068c:	ee66 6aa5 	vmul.f32	s13, s13, s11
20000690:	2d97      	cmp	r5, #151	; 0x97
20000692:	edc3 6a08 	vstr	s13, [r3, #32]
20000696:	edcd 6a06 	vstr	s13, [sp, #24]
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
2000069a:	eefc 6ac6 	vcvt.u32.f32	s13, s12
2000069e:	bf28      	it	cs
200006a0:	2597      	movcs	r5, #151	; 0x97
200006a2:	edcd 6a01 	vstr	s13, [sp, #4]
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
200006a6:	eb06 0585 	add.w	r5, r6, r5, lsl #2
200006aa:	edd5 6a00 	vldr	s13, [r5]
200006ae:	f89d 4004 	ldrb.w	r4, [sp, #4]
200006b2:	4675      	mov	r5, lr
200006b4:	2d97      	cmp	r5, #151	; 0x97
200006b6:	ee02 4a90 	vmov	s5, r4
200006ba:	bf28      	it	cs
200006bc:	2597      	movcs	r5, #151	; 0x97
200006be:	eb06 0585 	add.w	r5, r6, r5, lsl #2

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200006c2:	ed95 6a00 	vldr	s12, [r5]
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune);
200006c6:	7b5c      	ldrb	r4, [r3, #13]
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);
200006c8:	eef8 2ae2 	vcvt.f32.s32	s5, s5
200006cc:	ee36 6a66 	vsub.f32	s12, s12, s13
200006d0:	ee62 2aa1 	vmul.f32	s5, s5, s3
200006d4:	4464      	add	r4, ip
200006d6:	eee2 6a86 	vfma.f32	s13, s5, s12
200006da:	b2e4      	uxtb	r4, r4

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
200006dc:	eef4 6ac7 	vcmpe.f32	s13, s14
200006e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200006e4:	bfa8      	it	ge
200006e6:	eef0 6a47 	vmovge.f32	s13, s14
200006ea:	2c96      	cmp	r4, #150	; 0x96
200006ec:	bf98      	it	ls
200006ee:	4625      	movls	r5, r4

    return f * k_samplerate_recipf;
200006f0:	ee66 6aa5 	vmul.f32	s13, s13, s11
200006f4:	bf88      	it	hi
200006f6:	2597      	movhi	r5, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
200006f8:	eb06 0585 	add.w	r5, r6, r5, lsl #2
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.3f);
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.3f);
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.6f);
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
200006fc:	edc3 6a09 	vstr	s13, [r3, #36]	; 0x24
20000700:	edcd 6a07 	vstr	s13, [sp, #28]
20000704:	edd5 6a00 	vldr	s13, [r5]
   * @param note Note in [0-151] range, mod in [0-255] range.
   * @return     Corresponding 0-1 phase increment in floating point.
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
20000708:	1c65      	adds	r5, r4, #1
2000070a:	b2ed      	uxtb	r5, r5
2000070c:	2d96      	cmp	r5, #150	; 0x96
2000070e:	bf94      	ite	ls
20000710:	46ae      	movls	lr, r5
20000712:	f04f 0e97 	movhi.w	lr, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000716:	eb06 0e8e 	add.w	lr, r6, lr, lsl #2

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
2000071a:	ed9e 6a00 	vldr	s12, [lr]
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune);
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune * 0.6f);
            w0[8] = s_state.w0[8] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune * 0.3f);
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune * 0.3f);
2000071e:	f8df e0e4 	ldr.w	lr, [pc, #228]	; 20000804 <_hook_cycle+0x740>
20000722:	ee36 6a66 	vsub.f32	s12, s12, s13
20000726:	eeb0 2a66 	vmov.f32	s4, s13
2000072a:	eea6 2a05 	vfma.f32	s4, s12, s10

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
2000072e:	eeb4 2ac7 	vcmpe.f32	s4, s14
20000732:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000736:	eeb0 5a42 	vmov.f32	s10, s4

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
2000073a:	bfa8      	it	ge
2000073c:	eeb0 5a47 	vmovge.f32	s10, s14
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
20000740:	ee25 5a25 	vmul.f32	s10, s10, s11
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.6f);
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.3f);
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.3f);
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.6f);
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune);
20000744:	ed83 5a0a 	vstr	s10, [r3, #40]	; 0x28
20000748:	ed8d 5a08 	vstr	s10, [sp, #32]

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
2000074c:	eeb0 5a66 	vmov.f32	s10, s13
20000750:	eea6 5a03 	vfma.f32	s10, s12, s6

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000754:	eeb4 5ac7 	vcmpe.f32	s10, s14
20000758:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
2000075c:	bfa8      	it	ge
2000075e:	eeb0 5a47 	vmovge.f32	s10, s14
20000762:	ee25 5a25 	vmul.f32	s10, s10, s11
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune * 0.6f);
20000766:	ed83 5a0b 	vstr	s10, [r3, #44]	; 0x2c
2000076a:	ed8d 5a09 	vstr	s10, [sp, #36]	; 0x24

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
2000076e:	eeb0 5a66 	vmov.f32	s10, s13
20000772:	eea6 5a23 	vfma.f32	s10, s12, s7

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000776:	eeb4 5ac7 	vcmpe.f32	s10, s14
2000077a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
2000077e:	bfa8      	it	ge
20000780:	eeb0 5a47 	vmovge.f32	s10, s14
20000784:	ee25 5a25 	vmul.f32	s10, s10, s11
            w0[8] = s_state.w0[8] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune * 0.3f);
20000788:	ed83 5a0c 	vstr	s10, [r3, #48]	; 0x30
2000078c:	ed8d 5a0a 	vstr	s10, [sp, #40]	; 0x28

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000790:	eeb0 5a66 	vmov.f32	s10, s13
20000794:	eea6 5a04 	vfma.f32	s10, s12, s8
20000798:	eee6 6a24 	vfma.f32	s13, s12, s9

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
2000079c:	eeb4 5ac7 	vcmpe.f32	s10, s14
200007a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200007a4:	eef4 6ac7 	vcmpe.f32	s13, s14
200007a8:	bfa8      	it	ge
200007aa:	eeb0 5a47 	vmovge.f32	s10, s14
200007ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200007b2:	bfa8      	it	ge
200007b4:	eef0 6a47 	vmovge.f32	s13, s14
200007b8:	2c97      	cmp	r4, #151	; 0x97
200007ba:	ee66 6aa5 	vmul.f32	s13, s13, s11
200007be:	bf28      	it	cs
200007c0:	2497      	movcs	r4, #151	; 0x97
200007c2:	2d97      	cmp	r5, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
200007c4:	eb06 0484 	add.w	r4, r6, r4, lsl #2
200007c8:	bf28      	it	cs
200007ca:	2597      	movcs	r5, #151	; 0x97
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune * 0.3f);
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune * 0.6f);
200007cc:	edce 6a0e 	vstr	s13, [lr, #56]	; 0x38
200007d0:	edcd 6a0c 	vstr	s13, [sp, #48]	; 0x30
200007d4:	edd4 6a00 	vldr	s13, [r4]
200007d8:	eb06 0485 	add.w	r4, r6, r5, lsl #2

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200007dc:	ed94 6a00 	vldr	s12, [r4]
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
200007e0:	ee25 5a25 	vmul.f32	s10, s10, s11
200007e4:	ee36 6a66 	vsub.f32	s12, s12, s13
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.6f);
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune);
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune * 0.6f);
            w0[8] = s_state.w0[8] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune * 0.3f);
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune * 0.3f);
200007e8:	ed8e 5a0d 	vstr	s10, [lr, #52]	; 0x34
200007ec:	ed8d 5a0b 	vstr	s10, [sp, #44]	; 0x2c
200007f0:	eee6 6a22 	vfma.f32	s13, s12, s5
200007f4:	e198      	b.n	20000b28 <_hook_cycle+0xa64>
200007f6:	bf00      	nop
200007f8:	0800f100 	.word	0x0800f100
200007fc:	3f19999a 	.word	0x3f19999a
20000800:	3e99999a 	.word	0x3e99999a
20000804:	20001ee0 	.word	0x20001ee0
20000808:	3b808081 	.word	0x3b808081
2000080c:	37aec33e 	.word	0x37aec33e
20000810:	46b8ff49 	.word	0x46b8ff49
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune * 0.6f);
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune);
            break;
        case 2:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
20000814:	8885      	ldrh	r5, [r0, #4]
20000816:	ed93 2a1c 	vldr	s4, [r3, #112]	; 0x70
2000081a:	7b1c      	ldrb	r4, [r3, #12]
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);
2000081c:	ed5f 2a06 	vldr	s5, [pc, #-24]	; 20000808 <_hook_cycle+0x744>

    return f * k_samplerate_recipf;
20000820:	ed5f 5a06 	vldr	s11, [pc, #-24]	; 2000080c <_hook_cycle+0x748>
20000824:	0a2e      	lsrs	r6, r5, #8
20000826:	b2ed      	uxtb	r5, r5
20000828:	ee07 5a10 	vmov	s14, r5
2000082c:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
20000830:	4434      	add	r4, r6
20000832:	ee36 7a02 	vadd.f32	s14, s12, s4
20000836:	b2e4      	uxtb	r4, r4
20000838:	eebc 7ac7 	vcvt.u32.f32	s14, s14
2000083c:	2c96      	cmp	r4, #150	; 0x96
2000083e:	ed8d 7a01 	vstr	s14, [sp, #4]
20000842:	f89d 5004 	ldrb.w	r5, [sp, #4]

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000846:	ed1f 7a0e 	vldr	s14, [pc, #-56]	; 20000810 <_hook_cycle+0x74c>
2000084a:	ee04 5a10 	vmov	s8, r5
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
2000084e:	4dbd      	ldr	r5, [pc, #756]	; (20000b44 <_hook_cycle+0xa80>)
20000850:	bf94      	ite	ls
20000852:	46a6      	movls	lr, r4
20000854:	f04f 0e97 	movhi.w	lr, #151	; 0x97
20000858:	eb05 0e8e 	add.w	lr, r5, lr, lsl #2
2000085c:	edde 6a00 	vldr	s13, [lr]
   * @param note Note in [0-151] range, mod in [0-255] range.
   * @return     Corresponding 0-1 phase increment in floating point.
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
20000860:	f104 0e01 	add.w	lr, r4, #1
20000864:	fa5f fe8e 	uxtb.w	lr, lr
20000868:	f1be 0f96 	cmp.w	lr, #150	; 0x96
2000086c:	bf94      	ite	ls
2000086e:	46f4      	movls	ip, lr
20000870:	f04f 0c97 	movhi.w	ip, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000874:	eb05 0c8c 	add.w	ip, r5, ip, lsl #2

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000878:	ed9c 3a00 	vldr	s6, [ip]
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);
2000087c:	eeb8 4ac4 	vcvt.f32.s32	s8, s8
20000880:	ee33 3a66 	vsub.f32	s6, s6, s13
20000884:	ee24 4a22 	vmul.f32	s8, s8, s5
20000888:	eeb0 5a66 	vmov.f32	s10, s13
2000088c:	eea4 5a03 	vfma.f32	s10, s8, s6
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.5f);
20000890:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000894:	eeb4 5ac7 	vcmpe.f32	s10, s14
20000898:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
2000089c:	bfa8      	it	ge
2000089e:	eeb0 5a47 	vmovge.f32	s10, s14

    return f * k_samplerate_recipf;
200008a2:	ee25 5a25 	vmul.f32	s10, s10, s11
200008a6:	ee62 3a23 	vmul.f32	s7, s4, s7
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune * 0.3f);
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune * 0.6f);
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune);
            break;
        case 2:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
200008aa:	ed83 5a04 	vstr	s10, [r3, #16]
200008ae:	ed8d 5a02 	vstr	s10, [sp, #8]
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.5f);
200008b2:	ee36 5a23 	vadd.f32	s10, s12, s7
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.5f);
200008b6:	ee76 3a63 	vsub.f32	s7, s12, s7
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune * 0.6f);
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune);
            break;
        case 2:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.5f);
200008ba:	eebc 5ac5 	vcvt.u32.f32	s10, s10
200008be:	ed8d 5a01 	vstr	s10, [sp, #4]
200008c2:	f89d c004 	ldrb.w	ip, [sp, #4]
200008c6:	ee04 ca90 	vmov	s9, ip
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);
200008ca:	eef8 4ae4 	vcvt.f32.s32	s9, s9

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200008ce:	eeb0 5a66 	vmov.f32	s10, s13
200008d2:	ee64 4aa2 	vmul.f32	s9, s9, s5
200008d6:	eea4 5a83 	vfma.f32	s10, s9, s6

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
200008da:	eeb4 5ac7 	vcmpe.f32	s10, s14
200008de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200008e2:	bfa8      	it	ge
200008e4:	eeb0 5a47 	vmovge.f32	s10, s14

    return f * k_samplerate_recipf;
200008e8:	ee25 5a25 	vmul.f32	s10, s10, s11
200008ec:	ed83 5a05 	vstr	s10, [r3, #20]
200008f0:	ed8d 5a03 	vstr	s10, [sp, #12]
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.5f);
200008f4:	eebc 5ae3 	vcvt.u32.f32	s10, s7
200008f8:	ed8d 5a01 	vstr	s10, [sp, #4]
200008fc:	f89d c004 	ldrb.w	ip, [sp, #4]
20000900:	ee05 ca10 	vmov	s10, ip
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);
20000904:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
20000908:	ee25 5a22 	vmul.f32	s10, s10, s5

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
2000090c:	eee5 6a03 	vfma.f32	s13, s10, s6

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000910:	eef4 6ac7 	vcmpe.f32	s13, s14
20000914:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000918:	bfa8      	it	ge
2000091a:	eef0 6a47 	vmovge.f32	s13, s14

    return f * k_samplerate_recipf;
2000091e:	ee66 6aa5 	vmul.f32	s13, s13, s11
20000922:	2c97      	cmp	r4, #151	; 0x97
20000924:	edc3 6a06 	vstr	s13, [r3, #24]
20000928:	edcd 6a04 	vstr	s13, [sp, #16]
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
2000092c:	ee76 6a42 	vsub.f32	s13, s12, s4
20000930:	bf28      	it	cs
20000932:	2497      	movcs	r4, #151	; 0x97
20000934:	eefc 6ae6 	vcvt.u32.f32	s13, s13
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000938:	eb05 0484 	add.w	r4, r5, r4, lsl #2
2000093c:	edcd 6a01 	vstr	s13, [sp, #4]
20000940:	f89d c004 	ldrb.w	ip, [sp, #4]
20000944:	edd4 6a00 	vldr	s13, [r4]
20000948:	4674      	mov	r4, lr
2000094a:	2c97      	cmp	r4, #151	; 0x97
2000094c:	ee06 ca10 	vmov	s12, ip
20000950:	bf28      	it	cs
20000952:	2497      	movcs	r4, #151	; 0x97
20000954:	eb05 0484 	add.w	r4, r5, r4, lsl #2

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000958:	edd4 3a00 	vldr	s7, [r4]
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune);
2000095c:	7b5c      	ldrb	r4, [r3, #13]
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);
2000095e:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
20000962:	ee73 3ae6 	vsub.f32	s7, s7, s13
20000966:	ee26 6a22 	vmul.f32	s12, s12, s5
2000096a:	4434      	add	r4, r6
2000096c:	eee6 6a23 	vfma.f32	s13, s12, s7
20000970:	b2e4      	uxtb	r4, r4

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000972:	eef4 6ac7 	vcmpe.f32	s13, s14
20000976:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
2000097a:	bfa8      	it	ge
2000097c:	eef0 6a47 	vmovge.f32	s13, s14
20000980:	2c96      	cmp	r4, #150	; 0x96
20000982:	bf98      	it	ls
20000984:	46a6      	movls	lr, r4

    return f * k_samplerate_recipf;
20000986:	ee66 6aa5 	vmul.f32	s13, s13, s11
2000098a:	bf88      	it	hi
2000098c:	f04f 0e97 	movhi.w	lr, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000990:	eb05 0e8e 	add.w	lr, r5, lr, lsl #2
            break;
        case 2:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune * 0.5f);
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.5f);
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
20000994:	edc3 6a07 	vstr	s13, [r3, #28]
20000998:	edcd 6a05 	vstr	s13, [sp, #20]
2000099c:	edde 6a00 	vldr	s13, [lr]
   * @param note Note in [0-151] range, mod in [0-255] range.
   * @return     Corresponding 0-1 phase increment in floating point.
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
200009a0:	f104 0e01 	add.w	lr, r4, #1
200009a4:	fa5f fe8e 	uxtb.w	lr, lr
200009a8:	f1be 0f96 	cmp.w	lr, #150	; 0x96
200009ac:	bf94      	ite	ls
200009ae:	46f4      	movls	ip, lr
200009b0:	f04f 0c97 	movhi.w	ip, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
200009b4:	eb05 0c8c 	add.w	ip, r5, ip, lsl #2

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200009b8:	ed9c 3a00 	vldr	s6, [ip]
200009bc:	ee33 3a66 	vsub.f32	s6, s6, s13
200009c0:	eef0 3a66 	vmov.f32	s7, s13
200009c4:	eee3 3a04 	vfma.f32	s7, s6, s8

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
200009c8:	eef4 3ac7 	vcmpe.f32	s7, s14
200009cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200009d0:	bfa8      	it	ge
200009d2:	eef0 3a47 	vmovge.f32	s7, s14
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
200009d6:	ee63 3aa5 	vmul.f32	s7, s7, s11
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune);
200009da:	edc3 3a08 	vstr	s7, [r3, #32]
200009de:	edcd 3a06 	vstr	s7, [sp, #24]

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200009e2:	eef0 3a66 	vmov.f32	s7, s13
200009e6:	eee3 3a24 	vfma.f32	s7, s6, s9
200009ea:	eee3 6a05 	vfma.f32	s13, s6, s10

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
200009ee:	eef4 3ac7 	vcmpe.f32	s7, s14
200009f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200009f6:	eef4 6ac7 	vcmpe.f32	s13, s14
200009fa:	bfa8      	it	ge
200009fc:	eef0 3a47 	vmovge.f32	s7, s14
20000a00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000a04:	bfa8      	it	ge
20000a06:	eef0 6a47 	vmovge.f32	s13, s14
20000a0a:	2c97      	cmp	r4, #151	; 0x97
20000a0c:	bf28      	it	cs
20000a0e:	2497      	movcs	r4, #151	; 0x97
20000a10:	f1be 0f97 	cmp.w	lr, #151	; 0x97
20000a14:	ee63 3aa5 	vmul.f32	s7, s7, s11
20000a18:	ee66 6aa5 	vmul.f32	s13, s13, s11
20000a1c:	bf28      	it	cs
20000a1e:	f04f 0e97 	movcs.w	lr, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000a22:	eb05 0e8e 	add.w	lr, r5, lr, lsl #2
20000a26:	eb05 0484 	add.w	r4, r5, r4, lsl #2
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune * 0.5f);
20000a2a:	edc3 3a09 	vstr	s7, [r3, #36]	; 0x24
20000a2e:	edcd 3a07 	vstr	s7, [sp, #28]
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune * 0.5f);
20000a32:	edc3 6a0a 	vstr	s13, [r3, #40]	; 0x28
20000a36:	edcd 6a08 	vstr	s13, [sp, #32]
20000a3a:	edd4 6a00 	vldr	s13, [r4]

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000a3e:	edde 3a00 	vldr	s7, [lr]
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune);
            w0[8] = s_state.w0[8] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) + s_state.detune);
20000a42:	7b9c      	ldrb	r4, [r3, #14]
20000a44:	ee73 3ae6 	vsub.f32	s7, s7, s13
20000a48:	4426      	add	r6, r4
20000a4a:	eee3 6a86 	vfma.f32	s13, s7, s12
20000a4e:	b2f6      	uxtb	r6, r6

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000a50:	eef4 6ac7 	vcmpe.f32	s13, s14
20000a54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000a58:	bfa8      	it	ge
20000a5a:	eef0 6a47 	vmovge.f32	s13, s14
20000a5e:	2e96      	cmp	r6, #150	; 0x96
20000a60:	bf98      	it	ls
20000a62:	4634      	movls	r4, r6
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
20000a64:	ee66 6aa5 	vmul.f32	s13, s13, s11
20000a68:	bf88      	it	hi
20000a6a:	2497      	movhi	r4, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000a6c:	eb05 0484 	add.w	r4, r5, r4, lsl #2
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune * 0.5f);
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune);
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune * 0.5f);
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune * 0.5f);
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune);
20000a70:	edc3 6a0b 	vstr	s13, [r3, #44]	; 0x2c
20000a74:	edcd 6a09 	vstr	s13, [sp, #36]	; 0x24
20000a78:	edd4 6a00 	vldr	s13, [r4]
   * @param note Note in [0-151] range, mod in [0-255] range.
   * @return     Corresponding 0-1 phase increment in floating point.
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
20000a7c:	1c74      	adds	r4, r6, #1
20000a7e:	b2e4      	uxtb	r4, r4
20000a80:	2c96      	cmp	r4, #150	; 0x96
20000a82:	bf94      	ite	ls
20000a84:	46a6      	movls	lr, r4
20000a86:	f04f 0e97 	movhi.w	lr, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000a8a:	eb05 0e8e 	add.w	lr, r5, lr, lsl #2

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000a8e:	edde 3a00 	vldr	s7, [lr]
            w0[8] = s_state.w0[8] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) + s_state.detune);
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) + s_state.detune * 0.5f);
20000a92:	f8df e0b4 	ldr.w	lr, [pc, #180]	; 20000b48 <_hook_cycle+0xa84>
20000a96:	ee73 3ae6 	vsub.f32	s7, s7, s13
20000a9a:	eeb0 3a66 	vmov.f32	s6, s13
20000a9e:	eea3 3a84 	vfma.f32	s6, s7, s8

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000aa2:	eeb4 3ac7 	vcmpe.f32	s6, s14
20000aa6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000aaa:	eeb0 4a43 	vmov.f32	s8, s6

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000aae:	bfa8      	it	ge
20000ab0:	eeb0 4a47 	vmovge.f32	s8, s14
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
20000ab4:	ee24 4a25 	vmul.f32	s8, s8, s11
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune);
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune * 0.5f);
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune * 0.5f);
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune);
            w0[8] = s_state.w0[8] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) + s_state.detune);
20000ab8:	ed83 4a0c 	vstr	s8, [r3, #48]	; 0x30
20000abc:	ed8d 4a0a 	vstr	s8, [sp, #40]	; 0x28

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000ac0:	eeb0 4a66 	vmov.f32	s8, s13
20000ac4:	eea3 4aa4 	vfma.f32	s8, s7, s9
20000ac8:	eee3 6a85 	vfma.f32	s13, s7, s10

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000acc:	eeb4 4ac7 	vcmpe.f32	s8, s14
20000ad0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000ad4:	eef0 4a44 	vmov.f32	s9, s8

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000ad8:	eef4 6ac7 	vcmpe.f32	s13, s14
20000adc:	bfa8      	it	ge
20000ade:	eef0 4a47 	vmovge.f32	s9, s14
20000ae2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000ae6:	bfa8      	it	ge
20000ae8:	eef0 6a47 	vmovge.f32	s13, s14
20000aec:	2e97      	cmp	r6, #151	; 0x97
20000aee:	bf28      	it	cs
20000af0:	2697      	movcs	r6, #151	; 0x97
20000af2:	2c97      	cmp	r4, #151	; 0x97
20000af4:	ee66 6aa5 	vmul.f32	s13, s13, s11
20000af8:	bf28      	it	cs
20000afa:	2497      	movcs	r4, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000afc:	eb05 0686 	add.w	r6, r5, r6, lsl #2
20000b00:	eb05 0484 	add.w	r4, r5, r4, lsl #2
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) + s_state.detune * 0.5f);
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) - s_state.detune * 0.5f);
20000b04:	edce 6a0e 	vstr	s13, [lr, #56]	; 0x38
20000b08:	edcd 6a0c 	vstr	s13, [sp, #48]	; 0x30

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000b0c:	ed94 5a00 	vldr	s10, [r4]
20000b10:	edd6 6a00 	vldr	s13, [r6]
20000b14:	ee35 5a66 	vsub.f32	s10, s10, s13
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
20000b18:	ee64 4aa5 	vmul.f32	s9, s9, s11
20000b1c:	eee5 6a06 	vfma.f32	s13, s10, s12
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune);
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune * 0.5f);
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune * 0.5f);
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune);
            w0[8] = s_state.w0[8] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) + s_state.detune);
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) + s_state.detune * 0.5f);
20000b20:	edce 4a0d 	vstr	s9, [lr, #52]	; 0x34
20000b24:	edcd 4a0b 	vstr	s9, [sp, #44]	; 0x2c

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000b28:	eef4 6ac7 	vcmpe.f32	s13, s14
20000b2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000b30:	bfb8      	it	lt
20000b32:	eeb0 7a66 	vmovlt.f32	s14, s13
20000b36:	ee27 7a25 	vmul.f32	s14, s14, s11
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) - s_state.detune * 0.5f);
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) - s_state.detune);
20000b3a:	ed8e 7a0f 	vstr	s14, [lr, #60]	; 0x3c
20000b3e:	ed8d 7a0d 	vstr	s14, [sp, #52]	; 0x34
            break;
20000b42:	e1ab      	b.n	20000e9c <_hook_cycle+0xdd8>
20000b44:	0800f100 	.word	0x0800f100
20000b48:	20001ee0 	.word	0x20001ee0
20000b4c:	3b808081 	.word	0x3b808081
20000b50:	37aec33e 	.word	0x37aec33e
20000b54:	46b8ff49 	.word	0x46b8ff49
        case 3:
        case 4:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
20000b58:	8885      	ldrh	r5, [r0, #4]
20000b5a:	ed93 5a1c 	vldr	s10, [r3, #112]	; 0x70
20000b5e:	7b1c      	ldrb	r4, [r3, #12]
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);
20000b60:	ed5f 2a06 	vldr	s5, [pc, #-24]	; 20000b4c <_hook_cycle+0xa88>

    return f * k_samplerate_recipf;
20000b64:	ed5f 6a06 	vldr	s13, [pc, #-24]	; 20000b50 <_hook_cycle+0xa8c>
20000b68:	0a2e      	lsrs	r6, r5, #8
20000b6a:	b2ed      	uxtb	r5, r5
20000b6c:	ee05 5a90 	vmov	s11, r5
20000b70:	eef8 3ae5 	vcvt.f32.s32	s7, s11
20000b74:	4434      	add	r4, r6
20000b76:	ee33 7a85 	vadd.f32	s14, s7, s10
20000b7a:	b2e4      	uxtb	r4, r4
20000b7c:	eebc 7ac7 	vcvt.u32.f32	s14, s14
20000b80:	2c96      	cmp	r4, #150	; 0x96
20000b82:	ed8d 7a01 	vstr	s14, [sp, #4]
20000b86:	f89d 5004 	ldrb.w	r5, [sp, #4]
20000b8a:	ed1f 7a0e 	vldr	s14, [pc, #-56]	; 20000b54 <_hook_cycle+0xa90>
20000b8e:	ee04 5a90 	vmov	s9, r5
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000b92:	4de6      	ldr	r5, [pc, #920]	; (20000f2c <_hook_cycle+0xe68>)
20000b94:	bf94      	ite	ls
20000b96:	46a6      	movls	lr, r4
20000b98:	f04f 0e97 	movhi.w	lr, #151	; 0x97
20000b9c:	eb05 0e8e 	add.w	lr, r5, lr, lsl #2
20000ba0:	ed9e 6a00 	vldr	s12, [lr]
   * @param note Note in [0-151] range, mod in [0-255] range.
   * @return     Corresponding 0-1 phase increment in floating point.
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
20000ba4:	f104 0e01 	add.w	lr, r4, #1
20000ba8:	fa5f fe8e 	uxtb.w	lr, lr
20000bac:	f1be 0f96 	cmp.w	lr, #150	; 0x96
20000bb0:	bf94      	ite	ls
20000bb2:	46f4      	movls	ip, lr
20000bb4:	f04f 0c97 	movhi.w	ip, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000bb8:	eb05 0c8c 	add.w	ip, r5, ip, lsl #2

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000bbc:	ed9c 3a00 	vldr	s6, [ip]
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);
20000bc0:	eef8 4ae4 	vcvt.f32.s32	s9, s9
20000bc4:	ee33 3a46 	vsub.f32	s6, s6, s12
20000bc8:	ee64 4aa2 	vmul.f32	s9, s9, s5
20000bcc:	ee63 5aa2 	vmul.f32	s11, s7, s5
20000bd0:	eeb0 4a46 	vmov.f32	s8, s12
20000bd4:	eea4 4a83 	vfma.f32	s8, s9, s6
20000bd8:	eea5 6a83 	vfma.f32	s12, s11, s6

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000bdc:	eeb4 4ac7 	vcmpe.f32	s8, s14
20000be0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000be4:	eeb4 6ac7 	vcmpe.f32	s12, s14
20000be8:	bfa8      	it	ge
20000bea:	eeb0 4a47 	vmovge.f32	s8, s14
20000bee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000bf2:	bfa8      	it	ge
20000bf4:	eeb0 6a47 	vmovge.f32	s12, s14

    return f * k_samplerate_recipf;
20000bf8:	ee26 6a26 	vmul.f32	s12, s12, s13
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF));
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
20000bfc:	ee73 3ac5 	vsub.f32	s7, s7, s10
20000c00:	2c97      	cmp	r4, #151	; 0x97
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) - s_state.detune);
            break;
        case 3:
        case 4:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF));
20000c02:	ed83 6a05 	vstr	s12, [r3, #20]
20000c06:	ed8d 6a03 	vstr	s12, [sp, #12]
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
20000c0a:	eebc 6ae3 	vcvt.u32.f32	s12, s7
20000c0e:	bf28      	it	cs
20000c10:	2497      	movcs	r4, #151	; 0x97
20000c12:	ed8d 6a01 	vstr	s12, [sp, #4]
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000c16:	eb05 0484 	add.w	r4, r5, r4, lsl #2
20000c1a:	f89d c004 	ldrb.w	ip, [sp, #4]
20000c1e:	ed94 6a00 	vldr	s12, [r4]
20000c22:	4674      	mov	r4, lr
20000c24:	2c97      	cmp	r4, #151	; 0x97
20000c26:	ee05 ca10 	vmov	s10, ip
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
20000c2a:	ee24 4a26 	vmul.f32	s8, s8, s13
20000c2e:	bf28      	it	cs
20000c30:	2497      	movcs	r4, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000c32:	eb05 0484 	add.w	r4, r5, r4, lsl #2
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) - s_state.detune * 0.5f);
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) - s_state.detune);
            break;
        case 3:
        case 4:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
20000c36:	ed83 4a04 	vstr	s8, [r3, #16]
20000c3a:	ed8d 4a02 	vstr	s8, [sp, #8]
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);
20000c3e:	eeb8 5ac5 	vcvt.f32.s32	s10, s10

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000c42:	ed94 4a00 	vldr	s8, [r4]
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF));
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune);
20000c46:	7b5c      	ldrb	r4, [r3, #13]
20000c48:	ee25 5a22 	vmul.f32	s10, s10, s5
20000c4c:	ee34 4a46 	vsub.f32	s8, s8, s12
20000c50:	4434      	add	r4, r6
20000c52:	eea5 6a04 	vfma.f32	s12, s10, s8
20000c56:	b2e4      	uxtb	r4, r4

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000c58:	eeb4 6ac7 	vcmpe.f32	s12, s14
20000c5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000c60:	bfa8      	it	ge
20000c62:	eeb0 6a47 	vmovge.f32	s12, s14
20000c66:	2c96      	cmp	r4, #150	; 0x96
20000c68:	bf98      	it	ls
20000c6a:	46a6      	movls	lr, r4

    return f * k_samplerate_recipf;
20000c6c:	ee26 6a26 	vmul.f32	s12, s12, s13
20000c70:	bf88      	it	hi
20000c72:	f04f 0e97 	movhi.w	lr, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000c76:	eb05 0e8e 	add.w	lr, r5, lr, lsl #2
            break;
        case 3:
        case 4:
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF));
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
20000c7a:	ed83 6a06 	vstr	s12, [r3, #24]
20000c7e:	ed8d 6a04 	vstr	s12, [sp, #16]
20000c82:	ed9e 6a00 	vldr	s12, [lr]
   * @param note Note in [0-151] range, mod in [0-255] range.
   * @return     Corresponding 0-1 phase increment in floating point.
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
20000c86:	f104 0e01 	add.w	lr, r4, #1
20000c8a:	fa5f fe8e 	uxtb.w	lr, lr
20000c8e:	f1be 0f96 	cmp.w	lr, #150	; 0x96
20000c92:	bf94      	ite	ls
20000c94:	46f4      	movls	ip, lr
20000c96:	f04f 0c97 	movhi.w	ip, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000c9a:	eb05 0c8c 	add.w	ip, r5, ip, lsl #2

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000c9e:	eddc 3a00 	vldr	s7, [ip]
20000ca2:	ee73 3ac6 	vsub.f32	s7, s7, s12
20000ca6:	eeb0 4a46 	vmov.f32	s8, s12
20000caa:	eea3 4aa4 	vfma.f32	s8, s7, s9
20000cae:	eea3 6aa5 	vfma.f32	s12, s7, s11

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000cb2:	eeb4 4ac7 	vcmpe.f32	s8, s14
20000cb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000cba:	eeb4 6ac7 	vcmpe.f32	s12, s14
20000cbe:	bfa8      	it	ge
20000cc0:	eeb0 4a47 	vmovge.f32	s8, s14
20000cc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000cc8:	bfa8      	it	ge
20000cca:	eeb0 6a47 	vmovge.f32	s12, s14
20000cce:	2c97      	cmp	r4, #151	; 0x97
20000cd0:	bf28      	it	cs
20000cd2:	2497      	movcs	r4, #151	; 0x97
20000cd4:	f1be 0f97 	cmp.w	lr, #151	; 0x97
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
20000cd8:	ee24 4a26 	vmul.f32	s8, s8, s13
20000cdc:	ee26 6a26 	vmul.f32	s12, s12, s13
20000ce0:	bf28      	it	cs
20000ce2:	f04f 0e97 	movcs.w	lr, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000ce6:	eb05 0e8e 	add.w	lr, r5, lr, lsl #2
20000cea:	eb05 0484 	add.w	r4, r5, r4, lsl #2
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune);
20000cee:	ed83 4a07 	vstr	s8, [r3, #28]
20000cf2:	ed8d 4a05 	vstr	s8, [sp, #20]
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF));
20000cf6:	ed83 6a08 	vstr	s12, [r3, #32]

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000cfa:	ed9e 4a00 	vldr	s8, [lr]
20000cfe:	ed8d 6a06 	vstr	s12, [sp, #24]
20000d02:	ed94 6a00 	vldr	s12, [r4]
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune);
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) + s_state.detune);
20000d06:	7b9c      	ldrb	r4, [r3, #14]
20000d08:	ee34 4a46 	vsub.f32	s8, s8, s12
20000d0c:	4434      	add	r4, r6
20000d0e:	eea4 6a05 	vfma.f32	s12, s8, s10
20000d12:	b2e4      	uxtb	r4, r4

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000d14:	eeb4 6ac7 	vcmpe.f32	s12, s14
20000d18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000d1c:	bfa8      	it	ge
20000d1e:	eeb0 6a47 	vmovge.f32	s12, s14
20000d22:	2c96      	cmp	r4, #150	; 0x96
20000d24:	bf98      	it	ls
20000d26:	46a6      	movls	lr, r4
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
20000d28:	ee26 6a26 	vmul.f32	s12, s12, s13
20000d2c:	bf88      	it	hi
20000d2e:	f04f 0e97 	movhi.w	lr, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000d32:	eb05 0e8e 	add.w	lr, r5, lr, lsl #2
            w0[0] = s_state.w0[0] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) + s_state.detune);
            w0[1] = s_state.w0[1] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF));
            w0[2] = s_state.w0[2] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[0], (params->pitch & 0xFF) - s_state.detune);
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune);
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF));
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune);
20000d36:	ed83 6a09 	vstr	s12, [r3, #36]	; 0x24
20000d3a:	ed8d 6a07 	vstr	s12, [sp, #28]
20000d3e:	ed9e 6a00 	vldr	s12, [lr]
   * @param note Note in [0-151] range, mod in [0-255] range.
   * @return     Corresponding 0-1 phase increment in floating point.
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
20000d42:	f104 0e01 	add.w	lr, r4, #1
20000d46:	fa5f fe8e 	uxtb.w	lr, lr
20000d4a:	f1be 0f96 	cmp.w	lr, #150	; 0x96
20000d4e:	bf94      	ite	ls
20000d50:	46f4      	movls	ip, lr
20000d52:	f04f 0c97 	movhi.w	ip, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000d56:	eb05 0c8c 	add.w	ip, r5, ip, lsl #2

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000d5a:	eddc 3a00 	vldr	s7, [ip]
20000d5e:	ee73 3ac6 	vsub.f32	s7, s7, s12
20000d62:	eeb0 4a46 	vmov.f32	s8, s12
20000d66:	eea3 4aa4 	vfma.f32	s8, s7, s9
20000d6a:	eea3 6aa5 	vfma.f32	s12, s7, s11

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000d6e:	eeb4 4ac7 	vcmpe.f32	s8, s14
20000d72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000d76:	eeb4 6ac7 	vcmpe.f32	s12, s14
20000d7a:	bfa8      	it	ge
20000d7c:	eeb0 4a47 	vmovge.f32	s8, s14
20000d80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000d84:	bfa8      	it	ge
20000d86:	eeb0 6a47 	vmovge.f32	s12, s14
20000d8a:	2c97      	cmp	r4, #151	; 0x97
20000d8c:	bf28      	it	cs
20000d8e:	2497      	movcs	r4, #151	; 0x97
20000d90:	f1be 0f97 	cmp.w	lr, #151	; 0x97
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
20000d94:	ee24 4a26 	vmul.f32	s8, s8, s13
20000d98:	ee26 6a26 	vmul.f32	s12, s12, s13
20000d9c:	bf28      	it	cs
20000d9e:	f04f 0e97 	movcs.w	lr, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000da2:	eb05 0e8e 	add.w	lr, r5, lr, lsl #2
20000da6:	eb05 0484 	add.w	r4, r5, r4, lsl #2
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) + s_state.detune);
20000daa:	ed83 4a0a 	vstr	s8, [r3, #40]	; 0x28
20000dae:	ed8d 4a08 	vstr	s8, [sp, #32]

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000db2:	ed9e 4a00 	vldr	s8, [lr]
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF));
20000db6:	ed83 6a0b 	vstr	s12, [r3, #44]	; 0x2c
20000dba:	ed8d 6a09 	vstr	s12, [sp, #36]	; 0x24
20000dbe:	ed94 6a00 	vldr	s12, [r4]
            w0[8] = s_state.w0[8] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) - s_state.detune);
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[3], (params->pitch & 0xFF) + s_state.detune);
20000dc2:	7bdc      	ldrb	r4, [r3, #15]
20000dc4:	ee34 4a46 	vsub.f32	s8, s8, s12
20000dc8:	4426      	add	r6, r4
20000dca:	eea4 6a05 	vfma.f32	s12, s8, s10
20000dce:	b2f6      	uxtb	r6, r6

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000dd0:	eeb4 6ac7 	vcmpe.f32	s12, s14
20000dd4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000dd8:	bfa8      	it	ge
20000dda:	eeb0 6a47 	vmovge.f32	s12, s14
20000dde:	2e96      	cmp	r6, #150	; 0x96
20000de0:	bf98      	it	ls
20000de2:	4634      	movls	r4, r6
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
20000de4:	ee26 6a26 	vmul.f32	s12, s12, s13
20000de8:	bf88      	it	hi
20000dea:	2497      	movhi	r4, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000dec:	eb05 0484 	add.w	r4, r5, r4, lsl #2
            w0[3] = s_state.w0[3] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) + s_state.detune);
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF));
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune);
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) + s_state.detune);
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF));
            w0[8] = s_state.w0[8] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) - s_state.detune);
20000df0:	ed83 6a0c 	vstr	s12, [r3, #48]	; 0x30
20000df4:	ed8d 6a0a 	vstr	s12, [sp, #40]	; 0x28
20000df8:	ed94 6a00 	vldr	s12, [r4]
   * @param note Note in [0-151] range, mod in [0-255] range.
   * @return     Corresponding 0-1 phase increment in floating point.
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
20000dfc:	1c74      	adds	r4, r6, #1
20000dfe:	b2e4      	uxtb	r4, r4
20000e00:	2c96      	cmp	r4, #150	; 0x96
20000e02:	bf94      	ite	ls
20000e04:	46a6      	movls	lr, r4
20000e06:	f04f 0e97 	movhi.w	lr, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000e0a:	eb05 0e8e 	add.w	lr, r5, lr, lsl #2

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000e0e:	ed9e 4a00 	vldr	s8, [lr]
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[3], (params->pitch & 0xFF) + s_state.detune);
20000e12:	f8df e120 	ldr.w	lr, [pc, #288]	; 20000f34 <_hook_cycle+0xe70>
20000e16:	ee34 4a46 	vsub.f32	s8, s8, s12
20000e1a:	eef0 3a46 	vmov.f32	s7, s12
20000e1e:	eee4 3a24 	vfma.f32	s7, s8, s9
20000e22:	eea4 6a25 	vfma.f32	s12, s8, s11

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000e26:	eef4 3ac7 	vcmpe.f32	s7, s14
20000e2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000e2e:	eef0 4a63 	vmov.f32	s9, s7

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000e32:	eeb4 6ac7 	vcmpe.f32	s12, s14
20000e36:	bfa8      	it	ge
20000e38:	eef0 4a47 	vmovge.f32	s9, s14
20000e3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000e40:	bfa8      	it	ge
20000e42:	eeb0 6a47 	vmovge.f32	s12, s14
20000e46:	2e97      	cmp	r6, #151	; 0x97
20000e48:	bf28      	it	cs
20000e4a:	2697      	movcs	r6, #151	; 0x97
20000e4c:	2c97      	cmp	r4, #151	; 0x97
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
20000e4e:	ee26 6a26 	vmul.f32	s12, s12, s13
20000e52:	bf28      	it	cs
20000e54:	2497      	movcs	r4, #151	; 0x97
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000e56:	eb05 0686 	add.w	r6, r5, r6, lsl #2
20000e5a:	eb05 0484 	add.w	r4, r5, r4, lsl #2
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[3], (params->pitch & 0xFF));
20000e5e:	ed8e 6a0e 	vstr	s12, [lr, #56]	; 0x38
20000e62:	ed8d 6a0c 	vstr	s12, [sp, #48]	; 0x30

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000e66:	edd4 5a00 	vldr	s11, [r4]
20000e6a:	ed96 6a00 	vldr	s12, [r6]
20000e6e:	ee75 5ac6 	vsub.f32	s11, s11, s12
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
20000e72:	ee64 4aa6 	vmul.f32	s9, s9, s13
20000e76:	eea5 6a85 	vfma.f32	s12, s11, s10
            w0[4] = s_state.w0[4] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF));
            w0[5] = s_state.w0[5] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[1], (params->pitch & 0xFF) - s_state.detune);
            w0[6] = s_state.w0[6] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) + s_state.detune);
            w0[7] = s_state.w0[7] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF));
            w0[8] = s_state.w0[8] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[2], (params->pitch & 0xFF) - s_state.detune);
            w0[9] = s_state.w0[9] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[3], (params->pitch & 0xFF) + s_state.detune);
20000e7a:	edce 4a0d 	vstr	s9, [lr, #52]	; 0x34

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000e7e:	eeb4 6ac7 	vcmpe.f32	s12, s14
20000e82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000e86:	bfb8      	it	lt
20000e88:	eeb0 7a46 	vmovlt.f32	s14, s12
20000e8c:	ee27 7a26 	vmul.f32	s14, s14, s13
20000e90:	edcd 4a0b 	vstr	s9, [sp, #44]	; 0x2c
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[3], (params->pitch & 0xFF));
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[3], (params->pitch & 0xFF) - s_state.detune);
20000e94:	ed8e 7a0f 	vstr	s14, [lr, #60]	; 0x3c
20000e98:	ed8d 7a0d 	vstr	s14, [sp, #52]	; 0x34
20000e9c:	4d24      	ldr	r5, [pc, #144]	; (20000f30 <_hook_cycle+0xe6c>)
20000e9e:	ae0e      	add	r6, sp, #56	; 0x38
20000ea0:	f105 0930 	add.w	r9, r5, #48	; 0x30
20000ea4:	462c      	mov	r4, r5
20000ea6:	46b6      	mov	lr, r6
20000ea8:	f007 0701 	and.w	r7, r7, #1
            break;
    }
    
    for (int i = 0; i < 12; i++) {
        phase[i] = (flags & k_flag_reset) ? 0.f : s_state.phase[i];
20000eac:	b917      	cbnz	r7, 20000eb4 <_hook_cycle+0xdf0>
20000eae:	f8d4 c000 	ldr.w	ip, [r4]
20000eb2:	e001      	b.n	20000eb8 <_hook_cycle+0xdf4>
20000eb4:	f04f 0c00 	mov.w	ip, #0
20000eb8:	3404      	adds	r4, #4
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[3], (params->pitch & 0xFF));
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[3], (params->pitch & 0xFF) - s_state.detune);
            break;
    }
    
    for (int i = 0; i < 12; i++) {
20000eba:	45a1      	cmp	r9, r4
        phase[i] = (flags & k_flag_reset) ? 0.f : s_state.phase[i];
20000ebc:	f84e cb04 	str.w	ip, [lr], #4
            w0[10] = s_state.w0[10] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[3], (params->pitch & 0xFF));
            w0[11] = s_state.w0[11] = osc_w0f_for_note(((params->pitch)>>8) + s_state.notes[3], (params->pitch & 0xFF) - s_state.detune);
            break;
    }
    
    for (int i = 0; i < 12; i++) {
20000ec0:	d1f4      	bne.n	20000eac <_hook_cycle+0xde8>
        phase[i] = (flags & k_flag_reset) ? 0.f : s_state.phase[i];
    }
    // Get lfo parameters (q31 is a fixed-point 31 bit)
    const float lfo = s_state.lfo = q31_to_f32(params->shape_lfo);
20000ec2:	ed90 7a00 	vldr	s14, [r0]
20000ec6:	eeba 7ae0 	vcvt.f32.s32	s14, s14, #31
20000eca:	ed83 7a00 	vstr	s14, [r3]
    // Reset lfo if flag is on, otherwise just get next lfo value
    float lfoz = (flags & k_flag_reset) ? lfo : s_state.lfoz;
20000ece:	b91f      	cbnz	r7, 20000ed8 <_hook_cycle+0xe14>
20000ed0:	4818      	ldr	r0, [pc, #96]	; (20000f34 <_hook_cycle+0xe70>)
20000ed2:	ed90 4a01 	vldr	s8, [r0, #4]
20000ed6:	e001      	b.n	20000edc <_hook_cycle+0xe18>
20000ed8:	eeb0 4a47 	vmov.f32	s8, s14
    // LFO increment
    const float lfo_inc = (lfo - lfoz) / frames;
20000edc:	ee06 2a90 	vmov	s13, r2
20000ee0:	ee37 7a44 	vsub.f32	s14, s14, s8
20000ee4:	eef8 6a66 	vcvt.f32.u32	s13, s13
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
20000ee8:	eddf 3a13 	vldr	s7, [pc, #76]	; 20000f38 <_hook_cycle+0xe74>
    const uint32_t x0p = (uint32_t)x0f;

    const uint32_t x0 = x0p & k_wt_sine_mask;
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
20000eec:	f8df e050 	ldr.w	lr, [pc, #80]	; 20000f40 <_hook_cycle+0xe7c>
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
20000ef0:	f8df c050 	ldr.w	ip, [pc, #80]	; 20000f44 <_hook_cycle+0xe80>
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
20000ef4:	f8df 8050 	ldr.w	r8, [pc, #80]	; 20000f48 <_hook_cycle+0xe84>
                        osc_sqrf(phase[11])) * 0.1f
                      );
                break;
            case 2:
            case 3:
                sig = osc_softclipf(0.05f,
20000ef8:	ed9f 3a10 	vldr	s6, [pc, #64]	; 20000f3c <_hook_cycle+0xe78>
    // LFO increment
    const float lfo_inc = (lfo - lfoz) / frames;

    // yn = pointer to first buffer position
    q31_t * __restrict y = (q31_t *)yn; // pointer to current buffer position
    const q31_t * y_e = y + frames; // pointer to end of buffer
20000efc:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    // Get lfo parameters (q31 is a fixed-point 31 bit)
    const float lfo = s_state.lfo = q31_to_f32(params->shape_lfo);
    // Reset lfo if flag is on, otherwise just get next lfo value
    float lfoz = (flags & k_flag_reset) ? lfo : s_state.lfoz;
    // LFO increment
    const float lfo_inc = (lfo - lfoz) / frames;
20000f00:	eec7 2a26 	vdiv.f32	s5, s14, s13

    // yn = pointer to first buffer position
    q31_t * __restrict y = (q31_t *)yn; // pointer to current buffer position
    const q31_t * y_e = y + frames; // pointer to end of buffer
20000f04:	9201      	str	r2, [sp, #4]
20000f06:	4660      	mov	r0, ip
20000f08:	4672      	mov	r2, lr
20000f0a:	4644      	mov	r4, r8
20000f0c:	eeb0 7a63 	vmov.f32	s14, s7

    for (; y < y_e; ) { //Loop to fill buffer (why is it not a while?)
20000f10:	9f01      	ldr	r7, [sp, #4]
20000f12:	42b9      	cmp	r1, r7
20000f14:	f080 872c 	bcs.w	20001d70 <_hook_cycle+0x1cac>
        float sig;
        switch (s_state.wave_type) {
20000f18:	7a1f      	ldrb	r7, [r3, #8]
20000f1a:	2f03      	cmp	r7, #3
20000f1c:	f200 8709 	bhi.w	20001d32 <_hook_cycle+0x1c6e>
20000f20:	e8df f017 	tbh	[pc, r7, lsl #1]
20000f24:	02740014 	.word	0x02740014
20000f28:	04ef04ef 	.word	0x04ef04ef
20000f2c:	0800f100 	.word	0x0800f100
20000f30:	20001f20 	.word	0x20001f20
20000f34:	20001ee0 	.word	0x20001ee0
20000f38:	43800000 	.word	0x43800000
20000f3c:	3dcccccd 	.word	0x3dcccccd
20000f40:	08012bdc 	.word	0x08012bdc
20000f44:	08010f94 	.word	0x08010f94
20000f48:	08011db8 	.word	0x08011db8
            case 0:
                sig = osc_softclipf(0.05f,
                        (osc_sawf(phase[0]) +
20000f4c:	eddd 7a0e 	vldr	s15, [sp, #56]	; 0x38
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
20000f50:	eefc 6ae7 	vcvt.u32.f32	s13, s15
20000f54:	eeff 5a00 	vmov.f32	s11, #240	; 0xbf800000 -1.0
20000f58:	eef8 6a66 	vcvt.f32.u32	s13, s13
20000f5c:	ee77 6ae6 	vsub.f32	s13, s15, s13
20000f60:	ee66 6aa3 	vmul.f32	s13, s13, s7
    const uint32_t x0p = (uint32_t)x0f;
20000f64:	eefc 7ae6 	vcvt.u32.f32	s15, s13
20000f68:	ee17 ba90 	vmov	fp, s15
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
20000f6c:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x1 = x0 - 1;
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
    return sign*y0;
20000f70:	ee06 ba10 	vmov	s12, fp
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
20000f74:	bf87      	ittee	hi
20000f76:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
20000f7a:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
20000f7e:	f10b 0701 	addls.w	r7, fp, #1
20000f82:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
20000f84:	bf88      	it	hi
20000f86:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
    return sign*y0;
20000f8a:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
20000f8e:	eb08 0787 	add.w	r7, r8, r7, lsl #2
20000f92:	eb08 0a8a 	add.w	sl, r8, sl, lsl #2
20000f96:	edda 7a00 	vldr	s15, [sl]
    return sign*y0;
20000f9a:	ee76 6ac6 	vsub.f32	s13, s13, s12
20000f9e:	ed97 6a00 	vldr	s12, [r7]
20000fa2:	ee36 6a67 	vsub.f32	s12, s12, s15
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
20000fa6:	bf98      	it	ls
20000fa8:	eeb7 5a00 	vmovls.f32	s10, #112	; 0x3f800000  1.0
      x1 = x0 - 1;
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
    return sign*y0;
20000fac:	eee6 7a86 	vfma.f32	s15, s13, s12
                        osc_sawf(phase[1]) +
20000fb0:	ed9d 6a0f 	vldr	s12, [sp, #60]	; 0x3c
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
20000fb4:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
20000fb8:	bf88      	it	hi
20000fba:	eeb0 5a65 	vmovhi.f32	s10, s11
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
20000fbe:	eef8 6a66 	vcvt.f32.u32	s13, s13
      x1 = x0 - 1;
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
    return sign*y0;
20000fc2:	ee67 7a85 	vmul.f32	s15, s15, s10
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
20000fc6:	ee76 6a66 	vsub.f32	s13, s12, s13
20000fca:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
20000fce:	eebc 6ae6 	vcvt.u32.f32	s12, s13
20000fd2:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
20000fd6:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
20000fda:	bf87      	ittee	hi
20000fdc:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
20000fe0:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
20000fe4:	f10b 0701 	addls.w	r7, fp, #1
20000fe8:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
20000fea:	bf88      	it	hi
20000fec:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
    for (; y < y_e; ) { //Loop to fill buffer (why is it not a while?)
        float sig;
        switch (s_state.wave_type) {
            case 0:
                sig = osc_softclipf(0.05f,
                        (osc_sawf(phase[0]) +
20000ff0:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
20000ff4:	eb04 0787 	add.w	r7, r4, r7, lsl #2
20000ff8:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
20000ffc:	ed9a 5a00 	vldr	s10, [sl]
20001000:	ee76 6ac6 	vsub.f32	s13, s13, s12
20001004:	ed97 6a00 	vldr	s12, [r7]
20001008:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
2000100c:	bf98      	it	ls
2000100e:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
20001012:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sawf(phase[1]) +
                        osc_sawf(phase[2]) +
20001016:	ed9d 6a10 	vldr	s12, [sp, #64]	; 0x40
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
2000101a:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
2000101e:	bf88      	it	hi
20001020:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
20001024:	eef8 6a66 	vcvt.f32.u32	s13, s13
    for (; y < y_e; ) { //Loop to fill buffer (why is it not a while?)
        float sig;
        switch (s_state.wave_type) {
            case 0:
                sig = osc_softclipf(0.05f,
                        (osc_sawf(phase[0]) +
20001028:	eee5 7a24 	vfma.f32	s15, s10, s9
2000102c:	ee76 6a66 	vsub.f32	s13, s12, s13
20001030:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
20001034:	eebc 6ae6 	vcvt.u32.f32	s12, s13
20001038:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
2000103c:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
20001040:	bf87      	ittee	hi
20001042:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
20001046:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
2000104a:	f10b 0701 	addls.w	r7, fp, #1
2000104e:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
20001050:	bf88      	it	hi
20001052:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sawf(phase[1]) +
20001056:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
2000105a:	eb04 0787 	add.w	r7, r4, r7, lsl #2
2000105e:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
20001062:	ed9a 5a00 	vldr	s10, [sl]
20001066:	ee76 6ac6 	vsub.f32	s13, s13, s12
2000106a:	ed97 6a00 	vldr	s12, [r7]
2000106e:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
20001072:	bf98      	it	ls
20001074:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
20001078:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sawf(phase[2]) +
                        osc_sawf(phase[3]) +
2000107c:	ed9d 6a11 	vldr	s12, [sp, #68]	; 0x44
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
20001080:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
20001084:	bf88      	it	hi
20001086:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
2000108a:	eef8 6a66 	vcvt.f32.u32	s13, s13
        float sig;
        switch (s_state.wave_type) {
            case 0:
                sig = osc_softclipf(0.05f,
                        (osc_sawf(phase[0]) +
                        osc_sawf(phase[1]) +
2000108e:	eee5 7a24 	vfma.f32	s15, s10, s9
20001092:	ee76 6a66 	vsub.f32	s13, s12, s13
20001096:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
2000109a:	eebc 6ae6 	vcvt.u32.f32	s12, s13
2000109e:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
200010a2:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
200010a6:	bf87      	ittee	hi
200010a8:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
200010ac:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
200010b0:	f10b 0701 	addls.w	r7, fp, #1
200010b4:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
200010b6:	bf88      	it	hi
200010b8:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sawf(phase[2]) +
200010bc:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
200010c0:	eb04 0787 	add.w	r7, r4, r7, lsl #2
200010c4:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
200010c8:	ed9a 5a00 	vldr	s10, [sl]
200010cc:	ee76 6ac6 	vsub.f32	s13, s13, s12
200010d0:	ed97 6a00 	vldr	s12, [r7]
200010d4:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
200010d8:	bf98      	it	ls
200010da:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
200010de:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sawf(phase[3]) +
                        osc_sawf(phase[4]) +
200010e2:	ed9d 6a12 	vldr	s12, [sp, #72]	; 0x48
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
200010e6:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
200010ea:	bf88      	it	hi
200010ec:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
200010f0:	eef8 6a66 	vcvt.f32.u32	s13, s13
        switch (s_state.wave_type) {
            case 0:
                sig = osc_softclipf(0.05f,
                        (osc_sawf(phase[0]) +
                        osc_sawf(phase[1]) +
                        osc_sawf(phase[2]) +
200010f4:	eee5 7a24 	vfma.f32	s15, s10, s9
200010f8:	ee76 6a66 	vsub.f32	s13, s12, s13
200010fc:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
20001100:	eebc 6ae6 	vcvt.u32.f32	s12, s13
20001104:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
20001108:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
2000110c:	bf87      	ittee	hi
2000110e:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
20001112:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
20001116:	f10b 0701 	addls.w	r7, fp, #1
2000111a:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
2000111c:	bf88      	it	hi
2000111e:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sawf(phase[3]) +
20001122:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
20001126:	eb04 0787 	add.w	r7, r4, r7, lsl #2
2000112a:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
2000112e:	ed9a 5a00 	vldr	s10, [sl]
20001132:	ee76 6ac6 	vsub.f32	s13, s13, s12
20001136:	ed97 6a00 	vldr	s12, [r7]
2000113a:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
2000113e:	bf98      	it	ls
20001140:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
20001144:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sawf(phase[4]) +
                        osc_sawf(phase[5]) +
20001148:	ed9d 6a13 	vldr	s12, [sp, #76]	; 0x4c
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
2000114c:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
20001150:	bf88      	it	hi
20001152:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
20001156:	eef8 6a66 	vcvt.f32.u32	s13, s13
            case 0:
                sig = osc_softclipf(0.05f,
                        (osc_sawf(phase[0]) +
                        osc_sawf(phase[1]) +
                        osc_sawf(phase[2]) +
                        osc_sawf(phase[3]) +
2000115a:	eee5 7a24 	vfma.f32	s15, s10, s9
2000115e:	ee76 6a66 	vsub.f32	s13, s12, s13
20001162:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
20001166:	eebc 6ae6 	vcvt.u32.f32	s12, s13
2000116a:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
2000116e:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
20001172:	bf87      	ittee	hi
20001174:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
20001178:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
2000117c:	f10b 0701 	addls.w	r7, fp, #1
20001180:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
20001182:	bf88      	it	hi
20001184:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sawf(phase[4]) +
20001188:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
2000118c:	eb04 0787 	add.w	r7, r4, r7, lsl #2
20001190:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
20001194:	ed9a 5a00 	vldr	s10, [sl]
20001198:	ee76 6ac6 	vsub.f32	s13, s13, s12
2000119c:	ed97 6a00 	vldr	s12, [r7]
200011a0:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
200011a4:	bf98      	it	ls
200011a6:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
200011aa:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sawf(phase[5]) +
                        osc_sawf(phase[6]) +
200011ae:	ed9d 6a14 	vldr	s12, [sp, #80]	; 0x50
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
200011b2:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
200011b6:	bf88      	it	hi
200011b8:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
200011bc:	eef8 6a66 	vcvt.f32.u32	s13, s13
                sig = osc_softclipf(0.05f,
                        (osc_sawf(phase[0]) +
                        osc_sawf(phase[1]) +
                        osc_sawf(phase[2]) +
                        osc_sawf(phase[3]) +
                        osc_sawf(phase[4]) +
200011c0:	eee5 7a24 	vfma.f32	s15, s10, s9
200011c4:	ee76 6a66 	vsub.f32	s13, s12, s13
200011c8:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
200011cc:	eebc 6ae6 	vcvt.u32.f32	s12, s13
200011d0:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
200011d4:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
200011d8:	bf87      	ittee	hi
200011da:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
200011de:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
200011e2:	f10b 0701 	addls.w	r7, fp, #1
200011e6:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
200011e8:	bf88      	it	hi
200011ea:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sawf(phase[5]) +
200011ee:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
200011f2:	eb04 0787 	add.w	r7, r4, r7, lsl #2
200011f6:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
200011fa:	ed9a 5a00 	vldr	s10, [sl]
200011fe:	ee76 6ac6 	vsub.f32	s13, s13, s12
20001202:	ed97 6a00 	vldr	s12, [r7]
20001206:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
2000120a:	bf98      	it	ls
2000120c:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
20001210:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sawf(phase[6]) +
                        osc_sawf(phase[7]) +
20001214:	ed9d 6a15 	vldr	s12, [sp, #84]	; 0x54
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
20001218:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
2000121c:	bf88      	it	hi
2000121e:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
20001222:	eef8 6a66 	vcvt.f32.u32	s13, s13
                        (osc_sawf(phase[0]) +
                        osc_sawf(phase[1]) +
                        osc_sawf(phase[2]) +
                        osc_sawf(phase[3]) +
                        osc_sawf(phase[4]) +
                        osc_sawf(phase[5]) +
20001226:	eee5 7a24 	vfma.f32	s15, s10, s9
2000122a:	ee76 6a66 	vsub.f32	s13, s12, s13
2000122e:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
20001232:	eebc 6ae6 	vcvt.u32.f32	s12, s13
20001236:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
2000123a:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
2000123e:	bf87      	ittee	hi
20001240:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
20001244:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
20001248:	f10b 0701 	addls.w	r7, fp, #1
2000124c:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
2000124e:	bf88      	it	hi
20001250:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sawf(phase[6]) +
20001254:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
20001258:	eb04 0787 	add.w	r7, r4, r7, lsl #2
2000125c:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
20001260:	ed9a 5a00 	vldr	s10, [sl]
20001264:	ee76 6ac6 	vsub.f32	s13, s13, s12
20001268:	ed97 6a00 	vldr	s12, [r7]
2000126c:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
20001270:	bf98      	it	ls
20001272:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
20001276:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sawf(phase[7]) +
                        osc_sawf(phase[8]) +
2000127a:	ed9d 6a16 	vldr	s12, [sp, #88]	; 0x58
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
2000127e:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
20001282:	bf88      	it	hi
20001284:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
20001288:	eef8 6a66 	vcvt.f32.u32	s13, s13
                        osc_sawf(phase[1]) +
                        osc_sawf(phase[2]) +
                        osc_sawf(phase[3]) +
                        osc_sawf(phase[4]) +
                        osc_sawf(phase[5]) +
                        osc_sawf(phase[6]) +
2000128c:	eee5 7a24 	vfma.f32	s15, s10, s9
20001290:	ee76 6a66 	vsub.f32	s13, s12, s13
20001294:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
20001298:	eebc 6ae6 	vcvt.u32.f32	s12, s13
2000129c:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
200012a0:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
200012a4:	bf87      	ittee	hi
200012a6:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
200012aa:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
200012ae:	f10b 0701 	addls.w	r7, fp, #1
200012b2:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
200012b4:	bf88      	it	hi
200012b6:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sawf(phase[7]) +
200012ba:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
200012be:	eb04 0787 	add.w	r7, r4, r7, lsl #2
200012c2:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
200012c6:	ed9a 5a00 	vldr	s10, [sl]
200012ca:	ee76 6ac6 	vsub.f32	s13, s13, s12
200012ce:	ed97 6a00 	vldr	s12, [r7]
200012d2:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
200012d6:	bf98      	it	ls
200012d8:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
200012dc:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sawf(phase[8]) +
                        osc_sawf(phase[9]) +
200012e0:	ed9d 6a17 	vldr	s12, [sp, #92]	; 0x5c
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
200012e4:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
200012e8:	bf88      	it	hi
200012ea:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
200012ee:	eef8 6a66 	vcvt.f32.u32	s13, s13
                        osc_sawf(phase[2]) +
                        osc_sawf(phase[3]) +
                        osc_sawf(phase[4]) +
                        osc_sawf(phase[5]) +
                        osc_sawf(phase[6]) +
                        osc_sawf(phase[7]) +
200012f2:	eee5 7a24 	vfma.f32	s15, s10, s9
200012f6:	ee76 6a66 	vsub.f32	s13, s12, s13
200012fa:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
200012fe:	eebc 6ae6 	vcvt.u32.f32	s12, s13
20001302:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
20001306:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
2000130a:	bf87      	ittee	hi
2000130c:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
20001310:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
20001314:	f10b 0701 	addls.w	r7, fp, #1
20001318:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
2000131a:	bf88      	it	hi
2000131c:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sawf(phase[8]) +
20001320:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
20001324:	eb04 0787 	add.w	r7, r4, r7, lsl #2
20001328:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
2000132c:	ed9a 5a00 	vldr	s10, [sl]
20001330:	ee76 6ac6 	vsub.f32	s13, s13, s12
20001334:	ed97 6a00 	vldr	s12, [r7]
20001338:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
2000133c:	bf98      	it	ls
2000133e:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
20001342:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sawf(phase[9]) +
                        osc_sawf(phase[10]) +
20001346:	ed9d 6a18 	vldr	s12, [sp, #96]	; 0x60
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
2000134a:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
2000134e:	bf88      	it	hi
20001350:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
20001354:	eef8 6a66 	vcvt.f32.u32	s13, s13
                        osc_sawf(phase[3]) +
                        osc_sawf(phase[4]) +
                        osc_sawf(phase[5]) +
                        osc_sawf(phase[6]) +
                        osc_sawf(phase[7]) +
                        osc_sawf(phase[8]) +
20001358:	eee5 7a24 	vfma.f32	s15, s10, s9
2000135c:	ee76 6a66 	vsub.f32	s13, s12, s13
20001360:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
20001364:	eebc 6ae6 	vcvt.u32.f32	s12, s13
20001368:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
2000136c:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
20001370:	bf87      	ittee	hi
20001372:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
20001376:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
2000137a:	f10b 0701 	addls.w	r7, fp, #1
2000137e:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
20001380:	bf88      	it	hi
20001382:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sawf(phase[9]) +
20001386:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
2000138a:	eb04 0787 	add.w	r7, r4, r7, lsl #2
2000138e:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
20001392:	ed9a 5a00 	vldr	s10, [sl]
20001396:	ee76 6ac6 	vsub.f32	s13, s13, s12
2000139a:	ed97 6a00 	vldr	s12, [r7]
2000139e:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
200013a2:	bf98      	it	ls
200013a4:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
200013a8:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sawf(phase[10]) +
                        osc_sawf(phase[11])) * 0.1f
200013ac:	ed9d 6a19 	vldr	s12, [sp, #100]	; 0x64
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
200013b0:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
200013b4:	bf88      	it	hi
200013b6:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @return     Wave sample.
   */
  __fast_inline float osc_sawf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
200013ba:	eef8 6a66 	vcvt.f32.u32	s13, s13
                        osc_sawf(phase[4]) +
                        osc_sawf(phase[5]) +
                        osc_sawf(phase[6]) +
                        osc_sawf(phase[7]) +
                        osc_sawf(phase[8]) +
                        osc_sawf(phase[9]) +
200013be:	eee5 7a24 	vfma.f32	s15, s10, s9
200013c2:	ee76 6a66 	vsub.f32	s13, s12, s13
200013c6:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
200013ca:	eebc 6ae6 	vcvt.u32.f32	s12, s13
200013ce:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
200013d2:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
200013d6:	bf86      	itte	hi
200013d8:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
200013dc:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
200013e0:	46da      	movls	sl, fp

    for (; y < y_e; ) { //Loop to fill buffer (why is it not a while?)
        float sig;
        switch (s_state.wave_type) {
            case 0:
                sig = osc_softclipf(0.05f,
200013e2:	eeb8 6a46 	vcvt.f32.u32	s12, s12
200013e6:	bf94      	ite	ls
200013e8:	f10b 0701 	addls.w	r7, fp, #1
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
200013ec:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
200013f0:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
200013f4:	bf94      	ite	ls
200013f6:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
200013fa:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
    }
    
    const float y0 = linintf(x0f - x0p, wt_saw_lut_f[x0], wt_saw_lut_f[x1]);
200013fe:	ed9a 5a00 	vldr	s10, [sl]
20001402:	ee76 6ac6 	vsub.f32	s13, s13, s12
20001406:	eb04 0787 	add.w	r7, r4, r7, lsl #2
2000140a:	e25e      	b.n	200018ca <_hook_cycle+0x1806>
                        osc_sawf(phase[11])) * 0.1f
                      );
                break;
            case 1:
                sig = osc_softclipf(0.05f,
                        (osc_sqrf(phase[0]) +
2000140c:	eddd 7a0e 	vldr	s15, [sp, #56]	; 0x38
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
20001410:	eefc 6ae7 	vcvt.u32.f32	s13, s15
20001414:	eeff 5a00 	vmov.f32	s11, #240	; 0xbf800000 -1.0
20001418:	eef8 6a66 	vcvt.f32.u32	s13, s13
2000141c:	ee77 6ae6 	vsub.f32	s13, s15, s13
20001420:	ee66 6aa3 	vmul.f32	s13, s13, s7
    const uint32_t x0p = (uint32_t)x0f;
20001424:	eefc 7ae6 	vcvt.u32.f32	s15, s13
20001428:	ee17 ba90 	vmov	fp, s15
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
2000142c:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x1 = x0 - 1;
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
    return sign*y0;
20001430:	ee06 ba10 	vmov	s12, fp
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
20001434:	bf87      	ittee	hi
20001436:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
2000143a:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
2000143e:	f10b 0701 	addls.w	r7, fp, #1
20001442:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
20001444:	bf88      	it	hi
20001446:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
    return sign*y0;
2000144a:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
2000144e:	eb0c 0787 	add.w	r7, ip, r7, lsl #2
20001452:	eb0c 0a8a 	add.w	sl, ip, sl, lsl #2
20001456:	edda 7a00 	vldr	s15, [sl]
    return sign*y0;
2000145a:	ee76 6ac6 	vsub.f32	s13, s13, s12
2000145e:	ed97 6a00 	vldr	s12, [r7]
20001462:	ee36 6a67 	vsub.f32	s12, s12, s15
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
20001466:	bf98      	it	ls
20001468:	eeb7 5a00 	vmovls.f32	s10, #112	; 0x3f800000  1.0
      x1 = x0 - 1;
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
    return sign*y0;
2000146c:	eee6 7a86 	vfma.f32	s15, s13, s12
                        osc_sqrf(phase[1]) +
20001470:	ed9d 6a0f 	vldr	s12, [sp, #60]	; 0x3c
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
20001474:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
      sign = -1.f;
20001478:	bf88      	it	hi
2000147a:	eeb0 5a65 	vmovhi.f32	s10, s11
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
2000147e:	eef8 6a66 	vcvt.f32.u32	s13, s13
      x1 = x0 - 1;
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
    return sign*y0;
20001482:	ee67 7a85 	vmul.f32	s15, s15, s10
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
20001486:	ee76 6a66 	vsub.f32	s13, s12, s13
2000148a:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
2000148e:	eebc 6ae6 	vcvt.u32.f32	s12, s13
20001492:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
20001496:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
2000149a:	bf87      	ittee	hi
2000149c:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
200014a0:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
200014a4:	f10b 0701 	addls.w	r7, fp, #1
200014a8:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
200014aa:	bf88      	it	hi
200014ac:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sawf(phase[11])) * 0.1f
                      );
                break;
            case 1:
                sig = osc_softclipf(0.05f,
                        (osc_sqrf(phase[0]) +
200014b0:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
200014b4:	eb00 0787 	add.w	r7, r0, r7, lsl #2
200014b8:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
200014bc:	ed9a 5a00 	vldr	s10, [sl]
200014c0:	ee76 6ac6 	vsub.f32	s13, s13, s12
200014c4:	ed97 6a00 	vldr	s12, [r7]
200014c8:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
200014cc:	bf98      	it	ls
200014ce:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
200014d2:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sqrf(phase[1]) +
                        osc_sqrf(phase[2]) +
200014d6:	ed9d 6a10 	vldr	s12, [sp, #64]	; 0x40
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
200014da:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
      sign = -1.f;
200014de:	bf88      	it	hi
200014e0:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
200014e4:	eef8 6a66 	vcvt.f32.u32	s13, s13
                        osc_sawf(phase[11])) * 0.1f
                      );
                break;
            case 1:
                sig = osc_softclipf(0.05f,
                        (osc_sqrf(phase[0]) +
200014e8:	eee5 7a24 	vfma.f32	s15, s10, s9
200014ec:	ee76 6a66 	vsub.f32	s13, s12, s13
200014f0:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
200014f4:	eebc 6ae6 	vcvt.u32.f32	s12, s13
200014f8:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
200014fc:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
20001500:	bf87      	ittee	hi
20001502:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
20001506:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
2000150a:	f10b 0701 	addls.w	r7, fp, #1
2000150e:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
20001510:	bf88      	it	hi
20001512:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sqrf(phase[1]) +
20001516:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
2000151a:	eb00 0787 	add.w	r7, r0, r7, lsl #2
2000151e:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
20001522:	ed9a 5a00 	vldr	s10, [sl]
20001526:	ee76 6ac6 	vsub.f32	s13, s13, s12
2000152a:	ed97 6a00 	vldr	s12, [r7]
2000152e:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
20001532:	bf98      	it	ls
20001534:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
20001538:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sqrf(phase[2]) +
                        osc_sqrf(phase[3]) +
2000153c:	ed9d 6a11 	vldr	s12, [sp, #68]	; 0x44
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
20001540:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
      sign = -1.f;
20001544:	bf88      	it	hi
20001546:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
2000154a:	eef8 6a66 	vcvt.f32.u32	s13, s13
                      );
                break;
            case 1:
                sig = osc_softclipf(0.05f,
                        (osc_sqrf(phase[0]) +
                        osc_sqrf(phase[1]) +
2000154e:	eee5 7a24 	vfma.f32	s15, s10, s9
20001552:	ee76 6a66 	vsub.f32	s13, s12, s13
20001556:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
2000155a:	eebc 6ae6 	vcvt.u32.f32	s12, s13
2000155e:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
20001562:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
20001566:	bf87      	ittee	hi
20001568:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
2000156c:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
20001570:	f10b 0701 	addls.w	r7, fp, #1
20001574:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
20001576:	bf88      	it	hi
20001578:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sqrf(phase[2]) +
2000157c:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
20001580:	eb00 0787 	add.w	r7, r0, r7, lsl #2
20001584:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
20001588:	ed9a 5a00 	vldr	s10, [sl]
2000158c:	ee76 6ac6 	vsub.f32	s13, s13, s12
20001590:	ed97 6a00 	vldr	s12, [r7]
20001594:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
20001598:	bf98      	it	ls
2000159a:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
2000159e:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sqrf(phase[3]) +
                        osc_sqrf(phase[4]) +
200015a2:	ed9d 6a12 	vldr	s12, [sp, #72]	; 0x48
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
200015a6:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
      sign = -1.f;
200015aa:	bf88      	it	hi
200015ac:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
200015b0:	eef8 6a66 	vcvt.f32.u32	s13, s13
                break;
            case 1:
                sig = osc_softclipf(0.05f,
                        (osc_sqrf(phase[0]) +
                        osc_sqrf(phase[1]) +
                        osc_sqrf(phase[2]) +
200015b4:	eee5 7a24 	vfma.f32	s15, s10, s9
200015b8:	ee76 6a66 	vsub.f32	s13, s12, s13
200015bc:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
200015c0:	eebc 6ae6 	vcvt.u32.f32	s12, s13
200015c4:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
200015c8:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
200015cc:	bf87      	ittee	hi
200015ce:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
200015d2:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
200015d6:	f10b 0701 	addls.w	r7, fp, #1
200015da:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
200015dc:	bf88      	it	hi
200015de:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sqrf(phase[3]) +
200015e2:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
200015e6:	eb00 0787 	add.w	r7, r0, r7, lsl #2
200015ea:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
200015ee:	ed9a 5a00 	vldr	s10, [sl]
200015f2:	ee76 6ac6 	vsub.f32	s13, s13, s12
200015f6:	ed97 6a00 	vldr	s12, [r7]
200015fa:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
200015fe:	bf98      	it	ls
20001600:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
20001604:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sqrf(phase[4]) +
                        osc_sqrf(phase[5]) +
20001608:	ed9d 6a13 	vldr	s12, [sp, #76]	; 0x4c
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
2000160c:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
      sign = -1.f;
20001610:	bf88      	it	hi
20001612:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
20001616:	eef8 6a66 	vcvt.f32.u32	s13, s13
            case 1:
                sig = osc_softclipf(0.05f,
                        (osc_sqrf(phase[0]) +
                        osc_sqrf(phase[1]) +
                        osc_sqrf(phase[2]) +
                        osc_sqrf(phase[3]) +
2000161a:	eee5 7a24 	vfma.f32	s15, s10, s9
2000161e:	ee76 6a66 	vsub.f32	s13, s12, s13
20001622:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
20001626:	eebc 6ae6 	vcvt.u32.f32	s12, s13
2000162a:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
2000162e:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
20001632:	bf87      	ittee	hi
20001634:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
20001638:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
2000163c:	f10b 0701 	addls.w	r7, fp, #1
20001640:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
20001642:	bf88      	it	hi
20001644:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sqrf(phase[4]) +
20001648:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
2000164c:	eb00 0787 	add.w	r7, r0, r7, lsl #2
20001650:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
20001654:	ed9a 5a00 	vldr	s10, [sl]
20001658:	ee76 6ac6 	vsub.f32	s13, s13, s12
2000165c:	ed97 6a00 	vldr	s12, [r7]
20001660:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
20001664:	bf98      	it	ls
20001666:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
2000166a:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sqrf(phase[5]) +
                        osc_sqrf(phase[6]) +
2000166e:	ed9d 6a14 	vldr	s12, [sp, #80]	; 0x50
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
20001672:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
      sign = -1.f;
20001676:	bf88      	it	hi
20001678:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
2000167c:	eef8 6a66 	vcvt.f32.u32	s13, s13
                sig = osc_softclipf(0.05f,
                        (osc_sqrf(phase[0]) +
                        osc_sqrf(phase[1]) +
                        osc_sqrf(phase[2]) +
                        osc_sqrf(phase[3]) +
                        osc_sqrf(phase[4]) +
20001680:	eee5 7a24 	vfma.f32	s15, s10, s9
20001684:	ee76 6a66 	vsub.f32	s13, s12, s13
20001688:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
2000168c:	eebc 6ae6 	vcvt.u32.f32	s12, s13
20001690:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
20001694:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
20001698:	bf87      	ittee	hi
2000169a:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
2000169e:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
200016a2:	f10b 0701 	addls.w	r7, fp, #1
200016a6:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
200016a8:	bf88      	it	hi
200016aa:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sqrf(phase[5]) +
200016ae:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
200016b2:	eb00 0787 	add.w	r7, r0, r7, lsl #2
200016b6:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
200016ba:	ed9a 5a00 	vldr	s10, [sl]
200016be:	ee76 6ac6 	vsub.f32	s13, s13, s12
200016c2:	ed97 6a00 	vldr	s12, [r7]
200016c6:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
200016ca:	bf98      	it	ls
200016cc:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
200016d0:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sqrf(phase[6]) +
                        osc_sqrf(phase[7]) +
200016d4:	ed9d 6a15 	vldr	s12, [sp, #84]	; 0x54
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
200016d8:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
      sign = -1.f;
200016dc:	bf88      	it	hi
200016de:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
200016e2:	eef8 6a66 	vcvt.f32.u32	s13, s13
                        (osc_sqrf(phase[0]) +
                        osc_sqrf(phase[1]) +
                        osc_sqrf(phase[2]) +
                        osc_sqrf(phase[3]) +
                        osc_sqrf(phase[4]) +
                        osc_sqrf(phase[5]) +
200016e6:	eee5 7a24 	vfma.f32	s15, s10, s9
200016ea:	ee76 6a66 	vsub.f32	s13, s12, s13
200016ee:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
200016f2:	eebc 6ae6 	vcvt.u32.f32	s12, s13
200016f6:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
200016fa:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
200016fe:	bf87      	ittee	hi
20001700:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
20001704:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
20001708:	f10b 0701 	addls.w	r7, fp, #1
2000170c:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
2000170e:	bf88      	it	hi
20001710:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sqrf(phase[6]) +
20001714:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
20001718:	eb00 0787 	add.w	r7, r0, r7, lsl #2
2000171c:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
20001720:	ed9a 5a00 	vldr	s10, [sl]
20001724:	ee76 6ac6 	vsub.f32	s13, s13, s12
20001728:	ed97 6a00 	vldr	s12, [r7]
2000172c:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
20001730:	bf98      	it	ls
20001732:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
20001736:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sqrf(phase[7]) +
                        osc_sqrf(phase[8]) +
2000173a:	ed9d 6a16 	vldr	s12, [sp, #88]	; 0x58
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
2000173e:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
      sign = -1.f;
20001742:	bf88      	it	hi
20001744:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
20001748:	eef8 6a66 	vcvt.f32.u32	s13, s13
                        osc_sqrf(phase[1]) +
                        osc_sqrf(phase[2]) +
                        osc_sqrf(phase[3]) +
                        osc_sqrf(phase[4]) +
                        osc_sqrf(phase[5]) +
                        osc_sqrf(phase[6]) +
2000174c:	eee5 7a24 	vfma.f32	s15, s10, s9
20001750:	ee76 6a66 	vsub.f32	s13, s12, s13
20001754:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
20001758:	eebc 6ae6 	vcvt.u32.f32	s12, s13
2000175c:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
20001760:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
20001764:	bf87      	ittee	hi
20001766:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
2000176a:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
2000176e:	f10b 0701 	addls.w	r7, fp, #1
20001772:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
20001774:	bf88      	it	hi
20001776:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sqrf(phase[7]) +
2000177a:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
2000177e:	eb00 0787 	add.w	r7, r0, r7, lsl #2
20001782:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
20001786:	ed9a 5a00 	vldr	s10, [sl]
2000178a:	ee76 6ac6 	vsub.f32	s13, s13, s12
2000178e:	ed97 6a00 	vldr	s12, [r7]
20001792:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
20001796:	bf98      	it	ls
20001798:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
2000179c:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sqrf(phase[8]) +
                        osc_sqrf(phase[9]) +
200017a0:	ed9d 6a17 	vldr	s12, [sp, #92]	; 0x5c
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
200017a4:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
      sign = -1.f;
200017a8:	bf88      	it	hi
200017aa:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
200017ae:	eef8 6a66 	vcvt.f32.u32	s13, s13
                        osc_sqrf(phase[2]) +
                        osc_sqrf(phase[3]) +
                        osc_sqrf(phase[4]) +
                        osc_sqrf(phase[5]) +
                        osc_sqrf(phase[6]) +
                        osc_sqrf(phase[7]) +
200017b2:	eee5 7a24 	vfma.f32	s15, s10, s9
200017b6:	ee76 6a66 	vsub.f32	s13, s12, s13
200017ba:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
200017be:	eebc 6ae6 	vcvt.u32.f32	s12, s13
200017c2:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
200017c6:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
200017ca:	bf87      	ittee	hi
200017cc:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
200017d0:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
200017d4:	f10b 0701 	addls.w	r7, fp, #1
200017d8:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
200017da:	bf88      	it	hi
200017dc:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sqrf(phase[8]) +
200017e0:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
200017e4:	eb00 0787 	add.w	r7, r0, r7, lsl #2
200017e8:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
200017ec:	ed9a 5a00 	vldr	s10, [sl]
200017f0:	ee76 6ac6 	vsub.f32	s13, s13, s12
200017f4:	ed97 6a00 	vldr	s12, [r7]
200017f8:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
200017fc:	bf98      	it	ls
200017fe:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
20001802:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sqrf(phase[9]) +
                        osc_sqrf(phase[10]) +
20001806:	ed9d 6a18 	vldr	s12, [sp, #96]	; 0x60
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
2000180a:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
      sign = -1.f;
2000180e:	bf88      	it	hi
20001810:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
20001814:	eef8 6a66 	vcvt.f32.u32	s13, s13
                        osc_sqrf(phase[3]) +
                        osc_sqrf(phase[4]) +
                        osc_sqrf(phase[5]) +
                        osc_sqrf(phase[6]) +
                        osc_sqrf(phase[7]) +
                        osc_sqrf(phase[8]) +
20001818:	eee5 7a24 	vfma.f32	s15, s10, s9
2000181c:	ee76 6a66 	vsub.f32	s13, s12, s13
20001820:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
20001824:	eebc 6ae6 	vcvt.u32.f32	s12, s13
20001828:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
2000182c:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
20001830:	bf87      	ittee	hi
20001832:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
20001836:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
2000183a:	f10b 0701 	addls.w	r7, fp, #1
2000183e:	46da      	movls	sl, fp
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
20001840:	bf88      	it	hi
20001842:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
                        osc_sqrf(phase[9]) +
20001846:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
2000184a:	eb00 0787 	add.w	r7, r0, r7, lsl #2
2000184e:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
20001852:	ed9a 5a00 	vldr	s10, [sl]
20001856:	ee76 6ac6 	vsub.f32	s13, s13, s12
2000185a:	ed97 6a00 	vldr	s12, [r7]
2000185e:	ee36 6a45 	vsub.f32	s12, s12, s10
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
20001862:	bf98      	it	ls
20001864:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
20001868:	eea6 5a86 	vfma.f32	s10, s13, s12
                        osc_sqrf(phase[10]) +
                        osc_sqrf(phase[11])) * 0.1f
2000186c:	ed9d 6a19 	vldr	s12, [sp, #100]	; 0x64
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
20001870:	eefc 6ac6 	vcvt.u32.f32	s13, s12
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
      sign = -1.f;
20001874:	bf88      	it	hi
20001876:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_sqrf(float x) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
2000187a:	eef8 6a66 	vcvt.f32.u32	s13, s13
                        osc_sqrf(phase[4]) +
                        osc_sqrf(phase[5]) +
                        osc_sqrf(phase[6]) +
                        osc_sqrf(phase[7]) +
                        osc_sqrf(phase[8]) +
                        osc_sqrf(phase[9]) +
2000187e:	eee5 7a24 	vfma.f32	s15, s10, s9
20001882:	ee76 6a66 	vsub.f32	s13, s12, s13
20001886:	ee66 6a87 	vmul.f32	s13, s13, s14
    const uint32_t x0p = (uint32_t)x0f;
2000188a:	eebc 6ae6 	vcvt.u32.f32	s12, s13
2000188e:	ee16 ba10 	vmov	fp, s12
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
20001892:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
20001896:	bf86      	itte	hi
20001898:	f00b 077f 	andhi.w	r7, fp, #127	; 0x7f
2000189c:	f1c7 0a80 	rsbhi	sl, r7, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
200018a0:	46da      	movls	sl, fp
                        osc_sawf(phase[10]) +
                        osc_sawf(phase[11])) * 0.1f
                      );
                break;
            case 1:
                sig = osc_softclipf(0.05f,
200018a2:	eeb8 6a46 	vcvt.f32.u32	s12, s12
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
200018a6:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
200018aa:	bf94      	ite	ls
200018ac:	f10b 0701 	addls.w	r7, fp, #1
    float sign = 1.f;
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
200018b0:	f1c7 077f 	rsbhi	r7, r7, #127	; 0x7f
      sign = -1.f;
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
200018b4:	ed9a 5a00 	vldr	s10, [sl]
200018b8:	ee76 6ac6 	vsub.f32	s13, s13, s12
    
    const float x0f = 2.f * p * k_wt_sqr_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
200018bc:	bf94      	ite	ls
200018be:	eef7 4a00 	vmovls.f32	s9, #112	; 0x3f800000  1.0
    if (x0p >= k_wt_sqr_size) {
      x0 = k_wt_sqr_size - (x0p & k_wt_sqr_mask);
      x1 = x0 - 1;
      sign = -1.f;
200018c2:	eeff 4a00 	vmovhi.f32	s9, #240	; 0xbf800000 -1.0
    }
    
    const float y0 = linintf(x0f - x0p, wt_sqr_lut_f[x0], wt_sqr_lut_f[x1]);
200018c6:	eb00 0787 	add.w	r7, r0, r7, lsl #2
200018ca:	ed97 6a00 	vldr	s12, [r7]
200018ce:	ee36 6a45 	vsub.f32	s12, s12, s10
200018d2:	eea6 5a86 	vfma.f32	s10, s13, s12
200018d6:	eee5 7a24 	vfma.f32	s15, s10, s9
200018da:	ee67 7a83 	vmul.f32	s15, s15, s6
200018de:	eef4 7ae5 	vcmpe.f32	s15, s11
200018e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200018e6:	db09      	blt.n	200018fc <_hook_cycle+0x1838>
200018e8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
200018ec:	eef4 7ae6 	vcmpe.f32	s15, s13
200018f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200018f4:	bfa8      	it	ge
200018f6:	eef0 7a66 	vmovge.f32	s15, s13
200018fa:	e212      	b.n	20001d22 <_hook_cycle+0x1c5e>
200018fc:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
20001900:	e20f      	b.n	20001d22 <_hook_cycle+0x1c5e>
                      );
                break;
            case 2:
            case 3:
                sig = osc_softclipf(0.05f,
                        (osc_sinf(phase[0]) +
20001902:	eddd 7a0e 	vldr	s15, [sp, #56]	; 0x38
                        osc_sinf(phase[1]) +
20001906:	ed9d 2a0f 	vldr	s4, [sp, #60]	; 0x3c
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
2000190a:	eefc 4ae7 	vcvt.u32.f32	s9, s15
2000190e:	eef8 4a64 	vcvt.f32.u32	s9, s9
20001912:	ee77 4ae4 	vsub.f32	s9, s15, s9
20001916:	ee64 4aa3 	vmul.f32	s9, s9, s7
    const uint32_t x0p = (uint32_t)x0f;
2000191a:	eefc 7ae4 	vcvt.u32.f32	s15, s9
2000191e:	ee17 ba90 	vmov	fp, s15

    const uint32_t x0 = x0p & k_wt_sine_mask;
20001922:	f00b 077f 	and.w	r7, fp, #127	; 0x7f
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
20001926:	eb0e 0a87 	add.w	sl, lr, r7, lsl #2
2000192a:	3701      	adds	r7, #1

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
2000192c:	eef8 7a67 	vcvt.f32.u32	s15, s15
20001930:	f007 077f 	and.w	r7, r7, #127	; 0x7f
20001934:	eb0e 0787 	add.w	r7, lr, r7, lsl #2
20001938:	edda 5a00 	vldr	s11, [sl]
2000193c:	ee74 4ae7 	vsub.f32	s9, s9, s15
20001940:	edd7 7a00 	vldr	s15, [r7]
20001944:	ee77 7ae5 	vsub.f32	s15, s15, s11
    return (x0p < k_wt_sine_size)?y0:-y0;
20001948:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
2000194c:	eee4 5aa7 	vfma.f32	s11, s9, s15
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
20001950:	eefc 4ac2 	vcvt.u32.f32	s9, s4

    const uint32_t x0 = x0p & k_wt_sine_mask;
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
    return (x0p < k_wt_sine_size)?y0:-y0;
20001954:	bf88      	it	hi
20001956:	eef1 5a65 	vneghi.f32	s11, s11
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
2000195a:	eef8 4a64 	vcvt.f32.u32	s9, s9
2000195e:	ee72 4a64 	vsub.f32	s9, s4, s9
20001962:	ee64 4a87 	vmul.f32	s9, s9, s14
    const uint32_t x0p = (uint32_t)x0f;
20001966:	eefc 7ae4 	vcvt.u32.f32	s15, s9
2000196a:	ee17 ba90 	vmov	fp, s15

    const uint32_t x0 = x0p & k_wt_sine_mask;
2000196e:	f00b 077f 	and.w	r7, fp, #127	; 0x7f
20001972:	ee06 ba90 	vmov	s13, fp
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
20001976:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
2000197a:	3701      	adds	r7, #1
2000197c:	eef8 6a66 	vcvt.f32.u32	s13, s13
20001980:	f007 077f 	and.w	r7, r7, #127	; 0x7f
20001984:	eb02 0787 	add.w	r7, r2, r7, lsl #2
20001988:	edda 7a00 	vldr	s15, [sl]
2000198c:	ee74 4ae6 	vsub.f32	s9, s9, s13
20001990:	edd7 6a00 	vldr	s13, [r7]
20001994:	ee76 6ae7 	vsub.f32	s13, s13, s15
    return (x0p < k_wt_sine_size)?y0:-y0;
20001998:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
2000199c:	eee4 7aa6 	vfma.f32	s15, s9, s13
200019a0:	bf88      	it	hi
200019a2:	eef1 7a67 	vneghi.f32	s15, s15
                      );
                break;
            case 2:
            case 3:
                sig = osc_softclipf(0.05f,
                        (osc_sinf(phase[0]) +
200019a6:	ee37 5aa5 	vadd.f32	s10, s15, s11
                        osc_sinf(phase[1]) +
                        osc_sinf(phase[2]) +
200019aa:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
200019ae:	eebc 2ae7 	vcvt.u32.f32	s4, s15
200019b2:	eeb8 2a42 	vcvt.f32.u32	s4, s4
200019b6:	ee37 2ac2 	vsub.f32	s4, s15, s4
200019ba:	ee22 2a07 	vmul.f32	s4, s4, s14
    const uint32_t x0p = (uint32_t)x0f;
200019be:	eefc 7ac2 	vcvt.u32.f32	s15, s4
200019c2:	ee17 ba90 	vmov	fp, s15

    const uint32_t x0 = x0p & k_wt_sine_mask;
200019c6:	f00b 077f 	and.w	r7, fp, #127	; 0x7f
200019ca:	ee06 ba90 	vmov	s13, fp
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
200019ce:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
200019d2:	3701      	adds	r7, #1
200019d4:	eef8 6a66 	vcvt.f32.u32	s13, s13
200019d8:	f007 077f 	and.w	r7, r7, #127	; 0x7f
200019dc:	eb02 0787 	add.w	r7, r2, r7, lsl #2
200019e0:	edda 7a00 	vldr	s15, [sl]
200019e4:	ee32 2a66 	vsub.f32	s4, s4, s13
200019e8:	edd7 6a00 	vldr	s13, [r7]
200019ec:	ee76 6ae7 	vsub.f32	s13, s13, s15
    return (x0p < k_wt_sine_size)?y0:-y0;
200019f0:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
200019f4:	eee2 7a26 	vfma.f32	s15, s4, s13
                        osc_sinf(phase[3]) +
                        osc_sinf(phase[4]) +
200019f8:	eddd 6a12 	vldr	s13, [sp, #72]	; 0x48
200019fc:	bf88      	it	hi
200019fe:	eef1 7a67 	vneghi.f32	s15, s15
                break;
            case 2:
            case 3:
                sig = osc_softclipf(0.05f,
                        (osc_sinf(phase[0]) +
                        osc_sinf(phase[1]) +
20001a02:	ee75 5a27 	vadd.f32	s11, s10, s15
                        osc_sinf(phase[2]) +
                        osc_sinf(phase[3]) +
20001a06:	eddd 7a11 	vldr	s15, [sp, #68]	; 0x44
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
20001a0a:	eebc 2ae7 	vcvt.u32.f32	s4, s15
20001a0e:	eeb8 2a42 	vcvt.f32.u32	s4, s4
20001a12:	ee37 2ac2 	vsub.f32	s4, s15, s4
20001a16:	ee22 2a07 	vmul.f32	s4, s4, s14
    const uint32_t x0p = (uint32_t)x0f;
20001a1a:	eefc 7ac2 	vcvt.u32.f32	s15, s4
20001a1e:	ee17 ba90 	vmov	fp, s15

    const uint32_t x0 = x0p & k_wt_sine_mask;
20001a22:	f00b 077f 	and.w	r7, fp, #127	; 0x7f
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
20001a26:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
20001a2a:	3701      	adds	r7, #1
20001a2c:	eef8 7a67 	vcvt.f32.u32	s15, s15
20001a30:	f007 077f 	and.w	r7, r7, #127	; 0x7f
20001a34:	eb02 0787 	add.w	r7, r2, r7, lsl #2
20001a38:	ed9a 6a00 	vldr	s12, [sl]
20001a3c:	ee32 2a67 	vsub.f32	s4, s4, s15
20001a40:	edd7 7a00 	vldr	s15, [r7]
20001a44:	ee77 7ac6 	vsub.f32	s15, s15, s12
    return (x0p < k_wt_sine_size)?y0:-y0;
20001a48:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
20001a4c:	eea2 6a27 	vfma.f32	s12, s4, s15
20001a50:	bf88      	it	hi
20001a52:	eeb1 6a46 	vneghi.f32	s12, s12
            case 2:
            case 3:
                sig = osc_softclipf(0.05f,
                        (osc_sinf(phase[0]) +
                        osc_sinf(phase[1]) +
                        osc_sinf(phase[2]) +
20001a56:	ee75 7a86 	vadd.f32	s15, s11, s12
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
20001a5a:	eefc 5ae6 	vcvt.u32.f32	s11, s13
20001a5e:	eef8 5a65 	vcvt.f32.u32	s11, s11
20001a62:	ee76 5ae5 	vsub.f32	s11, s13, s11
20001a66:	ee65 5a87 	vmul.f32	s11, s11, s14
    const uint32_t x0p = (uint32_t)x0f;
20001a6a:	eefc 6ae5 	vcvt.u32.f32	s13, s11
20001a6e:	ee16 ba90 	vmov	fp, s13

    const uint32_t x0 = x0p & k_wt_sine_mask;
20001a72:	f00b 077f 	and.w	r7, fp, #127	; 0x7f
20001a76:	ee06 ba10 	vmov	s12, fp
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
20001a7a:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
20001a7e:	3701      	adds	r7, #1
20001a80:	eeb8 6a46 	vcvt.f32.u32	s12, s12
20001a84:	f007 077f 	and.w	r7, r7, #127	; 0x7f
20001a88:	eb02 0787 	add.w	r7, r2, r7, lsl #2
20001a8c:	edda 6a00 	vldr	s13, [sl]
20001a90:	ee75 5ac6 	vsub.f32	s11, s11, s12
20001a94:	ed97 6a00 	vldr	s12, [r7]
20001a98:	ee36 6a66 	vsub.f32	s12, s12, s13
    return (x0p < k_wt_sine_size)?y0:-y0;
20001a9c:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
20001aa0:	eee5 6a86 	vfma.f32	s13, s11, s12
20001aa4:	bf88      	it	hi
20001aa6:	eef1 6a66 	vneghi.f32	s13, s13
                        osc_sinf(phase[3]) +
20001aaa:	ee37 6aa6 	vadd.f32	s12, s15, s13
                        osc_sinf(phase[4]) +
                        osc_sinf(phase[5]) +
20001aae:	eddd 7a13 	vldr	s15, [sp, #76]	; 0x4c
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
20001ab2:	eebc 2ae7 	vcvt.u32.f32	s4, s15
20001ab6:	eeb8 2a42 	vcvt.f32.u32	s4, s4
20001aba:	ee37 2ac2 	vsub.f32	s4, s15, s4
20001abe:	ee22 2a07 	vmul.f32	s4, s4, s14
    const uint32_t x0p = (uint32_t)x0f;
20001ac2:	eefc 7ac2 	vcvt.u32.f32	s15, s4
20001ac6:	ee17 ba90 	vmov	fp, s15

    const uint32_t x0 = x0p & k_wt_sine_mask;
20001aca:	f00b 077f 	and.w	r7, fp, #127	; 0x7f
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
20001ace:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
20001ad2:	3701      	adds	r7, #1
20001ad4:	eef8 7a67 	vcvt.f32.u32	s15, s15
20001ad8:	f007 077f 	and.w	r7, r7, #127	; 0x7f
20001adc:	eb02 0787 	add.w	r7, r2, r7, lsl #2
20001ae0:	edda 4a00 	vldr	s9, [sl]
20001ae4:	ee32 2a67 	vsub.f32	s4, s4, s15
20001ae8:	edd7 7a00 	vldr	s15, [r7]
20001aec:	ee77 7ae4 	vsub.f32	s15, s15, s9
    return (x0p < k_wt_sine_size)?y0:-y0;
20001af0:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
20001af4:	eee2 4a27 	vfma.f32	s9, s4, s15
                        osc_sinf(phase[6]) +
20001af8:	eddd 7a14 	vldr	s15, [sp, #80]	; 0x50
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
20001afc:	eebc 2ae7 	vcvt.u32.f32	s4, s15

    const uint32_t x0 = x0p & k_wt_sine_mask;
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
    return (x0p < k_wt_sine_size)?y0:-y0;
20001b00:	bf88      	it	hi
20001b02:	eef1 4a64 	vneghi.f32	s9, s9
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
20001b06:	eeb8 2a42 	vcvt.f32.u32	s4, s4
                sig = osc_softclipf(0.05f,
                        (osc_sinf(phase[0]) +
                        osc_sinf(phase[1]) +
                        osc_sinf(phase[2]) +
                        osc_sinf(phase[3]) +
                        osc_sinf(phase[4]) +
20001b0a:	ee76 6a24 	vadd.f32	s13, s12, s9
20001b0e:	ee37 2ac2 	vsub.f32	s4, s15, s4
20001b12:	ee22 2a07 	vmul.f32	s4, s4, s14
    const uint32_t x0p = (uint32_t)x0f;
20001b16:	eefc 7ac2 	vcvt.u32.f32	s15, s4
20001b1a:	ee17 ba90 	vmov	fp, s15

    const uint32_t x0 = x0p & k_wt_sine_mask;
20001b1e:	f00b 077f 	and.w	r7, fp, #127	; 0x7f
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
20001b22:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
20001b26:	3701      	adds	r7, #1
20001b28:	eef8 7a67 	vcvt.f32.u32	s15, s15
20001b2c:	f007 077f 	and.w	r7, r7, #127	; 0x7f
20001b30:	eb02 0787 	add.w	r7, r2, r7, lsl #2
20001b34:	ed9a 5a00 	vldr	s10, [sl]
20001b38:	ee32 2a67 	vsub.f32	s4, s4, s15
20001b3c:	edd7 7a00 	vldr	s15, [r7]
20001b40:	ee77 7ac5 	vsub.f32	s15, s15, s10
    return (x0p < k_wt_sine_size)?y0:-y0;
20001b44:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
20001b48:	eea2 5a27 	vfma.f32	s10, s4, s15
                        osc_sinf(phase[5]) +
                        osc_sinf(phase[6]) +
                        osc_sinf(phase[7]) +
20001b4c:	eddd 7a15 	vldr	s15, [sp, #84]	; 0x54
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
20001b50:	eebc 2ae7 	vcvt.u32.f32	s4, s15

    const uint32_t x0 = x0p & k_wt_sine_mask;
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
    return (x0p < k_wt_sine_size)?y0:-y0;
20001b54:	bf88      	it	hi
20001b56:	eeb1 5a45 	vneghi.f32	s10, s10
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
20001b5a:	eeb8 2a42 	vcvt.f32.u32	s4, s4
                        (osc_sinf(phase[0]) +
                        osc_sinf(phase[1]) +
                        osc_sinf(phase[2]) +
                        osc_sinf(phase[3]) +
                        osc_sinf(phase[4]) +
                        osc_sinf(phase[5]) +
20001b5e:	ee76 4a85 	vadd.f32	s9, s13, s10
20001b62:	ee37 2ac2 	vsub.f32	s4, s15, s4
20001b66:	ee22 2a07 	vmul.f32	s4, s4, s14
    const uint32_t x0p = (uint32_t)x0f;
20001b6a:	eefc 7ac2 	vcvt.u32.f32	s15, s4
20001b6e:	ee17 ba90 	vmov	fp, s15

    const uint32_t x0 = x0p & k_wt_sine_mask;
20001b72:	f00b 077f 	and.w	r7, fp, #127	; 0x7f
20001b76:	ee06 ba90 	vmov	s13, fp
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
20001b7a:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
20001b7e:	3701      	adds	r7, #1
20001b80:	eef8 6a66 	vcvt.f32.u32	s13, s13
20001b84:	f007 077f 	and.w	r7, r7, #127	; 0x7f
20001b88:	eb02 0787 	add.w	r7, r2, r7, lsl #2
20001b8c:	edda 7a00 	vldr	s15, [sl]
20001b90:	ee32 2a66 	vsub.f32	s4, s4, s13
20001b94:	edd7 6a00 	vldr	s13, [r7]
20001b98:	ee76 6ae7 	vsub.f32	s13, s13, s15
    return (x0p < k_wt_sine_size)?y0:-y0;
20001b9c:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
20001ba0:	eee2 7a26 	vfma.f32	s15, s4, s13
                        osc_sinf(phase[6]) +
                        osc_sinf(phase[7]) +
                        osc_sinf(phase[8]) +
                        osc_sinf(phase[9]) +
20001ba4:	eddd 6a17 	vldr	s13, [sp, #92]	; 0x5c
20001ba8:	bf88      	it	hi
20001baa:	eef1 7a67 	vneghi.f32	s15, s15
                        osc_sinf(phase[1]) +
                        osc_sinf(phase[2]) +
                        osc_sinf(phase[3]) +
                        osc_sinf(phase[4]) +
                        osc_sinf(phase[5]) +
                        osc_sinf(phase[6]) +
20001bae:	ee34 5aa7 	vadd.f32	s10, s9, s15
                        osc_sinf(phase[7]) +
                        osc_sinf(phase[8]) +
20001bb2:	eddd 7a16 	vldr	s15, [sp, #88]	; 0x58
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
20001bb6:	eefc 4ae7 	vcvt.u32.f32	s9, s15
20001bba:	eef8 4a64 	vcvt.f32.u32	s9, s9
20001bbe:	ee77 4ae4 	vsub.f32	s9, s15, s9
20001bc2:	ee64 4a87 	vmul.f32	s9, s9, s14
    const uint32_t x0p = (uint32_t)x0f;
20001bc6:	eefc 7ae4 	vcvt.u32.f32	s15, s9
20001bca:	ee17 ba90 	vmov	fp, s15

    const uint32_t x0 = x0p & k_wt_sine_mask;
20001bce:	f00b 077f 	and.w	r7, fp, #127	; 0x7f
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
20001bd2:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
20001bd6:	3701      	adds	r7, #1
20001bd8:	eef8 7a67 	vcvt.f32.u32	s15, s15
20001bdc:	f007 077f 	and.w	r7, r7, #127	; 0x7f
20001be0:	eb02 0787 	add.w	r7, r2, r7, lsl #2
20001be4:	edda 5a00 	vldr	s11, [sl]
20001be8:	ee74 4ae7 	vsub.f32	s9, s9, s15
20001bec:	edd7 7a00 	vldr	s15, [r7]
20001bf0:	ee77 7ae5 	vsub.f32	s15, s15, s11
    return (x0p < k_wt_sine_size)?y0:-y0;
20001bf4:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
20001bf8:	eee4 5aa7 	vfma.f32	s11, s9, s15
20001bfc:	bf88      	it	hi
20001bfe:	eef1 5a65 	vneghi.f32	s11, s11
                        osc_sinf(phase[2]) +
                        osc_sinf(phase[3]) +
                        osc_sinf(phase[4]) +
                        osc_sinf(phase[5]) +
                        osc_sinf(phase[6]) +
                        osc_sinf(phase[7]) +
20001c02:	ee75 7a25 	vadd.f32	s15, s10, s11
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
20001c06:	eebc 5ae6 	vcvt.u32.f32	s10, s13
20001c0a:	eeb8 5a45 	vcvt.f32.u32	s10, s10
20001c0e:	ee36 5ac5 	vsub.f32	s10, s13, s10
20001c12:	ee25 5a07 	vmul.f32	s10, s10, s14
    const uint32_t x0p = (uint32_t)x0f;
20001c16:	eefc 6ac5 	vcvt.u32.f32	s13, s10
20001c1a:	ee16 ba90 	vmov	fp, s13

    const uint32_t x0 = x0p & k_wt_sine_mask;
20001c1e:	f00b 077f 	and.w	r7, fp, #127	; 0x7f
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
20001c22:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
20001c26:	3701      	adds	r7, #1
20001c28:	eef8 6a66 	vcvt.f32.u32	s13, s13
20001c2c:	f007 077f 	and.w	r7, r7, #127	; 0x7f
20001c30:	eb02 0787 	add.w	r7, r2, r7, lsl #2
20001c34:	ed9a 6a00 	vldr	s12, [sl]
20001c38:	ee35 5a66 	vsub.f32	s10, s10, s13
20001c3c:	edd7 6a00 	vldr	s13, [r7]
20001c40:	ee76 6ac6 	vsub.f32	s13, s13, s12
    return (x0p < k_wt_sine_size)?y0:-y0;
20001c44:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
20001c48:	eea5 6a26 	vfma.f32	s12, s10, s13
20001c4c:	bf88      	it	hi
20001c4e:	eeb1 6a46 	vneghi.f32	s12, s12
                        osc_sinf(phase[8]) +
20001c52:	ee77 5a86 	vadd.f32	s11, s15, s12
                        osc_sinf(phase[9]) +
                        osc_sinf(phase[10]) +
20001c56:	eddd 7a18 	vldr	s15, [sp, #96]	; 0x60
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
20001c5a:	eebc 5ae7 	vcvt.u32.f32	s10, s15
20001c5e:	eeb8 5a45 	vcvt.f32.u32	s10, s10
20001c62:	ee37 5ac5 	vsub.f32	s10, s15, s10
20001c66:	ee25 5a07 	vmul.f32	s10, s10, s14
    const uint32_t x0p = (uint32_t)x0f;
20001c6a:	eefc 7ac5 	vcvt.u32.f32	s15, s10
20001c6e:	ee17 ba90 	vmov	fp, s15

    const uint32_t x0 = x0p & k_wt_sine_mask;
20001c72:	f00b 077f 	and.w	r7, fp, #127	; 0x7f
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
20001c76:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
20001c7a:	3701      	adds	r7, #1
20001c7c:	eef8 7a67 	vcvt.f32.u32	s15, s15
20001c80:	f007 077f 	and.w	r7, r7, #127	; 0x7f
20001c84:	eb02 0787 	add.w	r7, r2, r7, lsl #2
20001c88:	edda 6a00 	vldr	s13, [sl]
20001c8c:	ee35 5a67 	vsub.f32	s10, s10, s15
20001c90:	edd7 7a00 	vldr	s15, [r7]
20001c94:	ee77 7ae6 	vsub.f32	s15, s15, s13
    return (x0p < k_wt_sine_size)?y0:-y0;
20001c98:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
20001c9c:	eee5 6a27 	vfma.f32	s13, s10, s15
                        osc_sinf(phase[11])) * 0.1f
20001ca0:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
20001ca4:	bf88      	it	hi
20001ca6:	eef1 6a66 	vneghi.f32	s13, s13
                        osc_sinf(phase[4]) +
                        osc_sinf(phase[5]) +
                        osc_sinf(phase[6]) +
                        osc_sinf(phase[7]) +
                        osc_sinf(phase[8]) +
                        osc_sinf(phase[9]) +
20001caa:	ee35 6aa6 	vadd.f32	s12, s11, s13
   */
  __fast_inline float osc_sinf(float x) {
    const float p = x - (uint32_t)x;
    
    // half period stored -- wrap around and invert
    const float x0f = 2.f * p * k_wt_sine_size;
20001cae:	eefc 5ae7 	vcvt.u32.f32	s11, s15
20001cb2:	eef8 5a65 	vcvt.f32.u32	s11, s11
20001cb6:	ee77 5ae5 	vsub.f32	s11, s15, s11
20001cba:	ee65 5a87 	vmul.f32	s11, s11, s14
    const uint32_t x0p = (uint32_t)x0f;
20001cbe:	eefc 7ae5 	vcvt.u32.f32	s15, s11
20001cc2:	ee17 ba90 	vmov	fp, s15

    const uint32_t x0 = x0p & k_wt_sine_mask;
20001cc6:	f00b 077f 	and.w	r7, fp, #127	; 0x7f
    const uint32_t x1 = (x0 + 1) & k_wt_sine_mask;
    
    const float y0 = linintf(x0f - x0p, wt_sine_lut_f[x0], wt_sine_lut_f[x1]);
20001cca:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
20001cce:	3701      	adds	r7, #1
20001cd0:	eef8 7a67 	vcvt.f32.u32	s15, s15
20001cd4:	f007 077f 	and.w	r7, r7, #127	; 0x7f
20001cd8:	eb02 0787 	add.w	r7, r2, r7, lsl #2
20001cdc:	edda 6a00 	vldr	s13, [sl]
20001ce0:	ee75 5ae7 	vsub.f32	s11, s11, s15
20001ce4:	edd7 7a00 	vldr	s15, [r7]
20001ce8:	ee77 7ae6 	vsub.f32	s15, s15, s13
    return (x0p < k_wt_sine_size)?y0:-y0;
20001cec:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
20001cf0:	eee5 6aa7 	vfma.f32	s13, s11, s15

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20001cf4:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
20001cf8:	bf88      	it	hi
20001cfa:	eef1 6a66 	vneghi.f32	s13, s13
                        osc_sqrf(phase[11])) * 0.1f
                      );
                break;
            case 2:
            case 3:
                sig = osc_softclipf(0.05f,
20001cfe:	ee76 6a26 	vadd.f32	s13, s12, s13
20001d02:	ee66 6a83 	vmul.f32	s13, s13, s6
20001d06:	eef4 6ae7 	vcmpe.f32	s13, s15
20001d0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20001d0e:	db08      	blt.n	20001d22 <_hook_cycle+0x1c5e>
20001d10:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
20001d14:	eef4 6ae7 	vcmpe.f32	s13, s15
20001d18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20001d1c:	bfb8      	it	lt
20001d1e:	eef0 7a66 	vmovlt.f32	s15, s13
   * @return     Clipped value in [-(1-c), (1-c)].
   */
  __fast_inline float osc_softclipf(const float c, float x)
  {
    x = clip1m1f(x);
    return x - c * (x*x*x);
20001d22:	ee67 6aa7 	vmul.f32	s13, s15, s15
20001d26:	ed9f 6a18 	vldr	s12, [pc, #96]	; 20001d88 <_hook_cycle+0x1cc4>
20001d2a:	ee67 6ae6 	vnmul.f32	s13, s15, s13
20001d2e:	eee6 7a86 	vfma.f32	s15, s13, s12
20001d32:	f10d 0a08 	add.w	sl, sp, #8
20001d36:	f10d 0b68 	add.w	fp, sp, #104	; 0x68
                        osc_sinf(phase[10]) +
                        osc_sinf(phase[11])) * 0.1f
                      );
                break;
        }
        *(y++) = f32_to_q31(sig);
20001d3a:	eef0 6a67 	vmov.f32	s13, s15
20001d3e:	eefe 6ae0 	vcvt.s32.f32	s13, s13, #31
20001d42:	4637      	mov	r7, r6
20001d44:	ece1 6a01 	vstmia	r1!, {s13}
        for (int i = 0; i < 12; i++) {
            phase[i] += w0[i];
20001d48:	ed97 6a00 	vldr	s12, [r7]
20001d4c:	ecfa 6a01 	vldmia	sl!, {s13}
20001d50:	ee76 6a86 	vadd.f32	s13, s13, s12
            phase[i] -= (uint32_t)phase[i];
20001d54:	eebc 6ae6 	vcvt.u32.f32	s12, s13
20001d58:	eeb8 6a46 	vcvt.f32.u32	s12, s12
20001d5c:	ee76 6ac6 	vsub.f32	s13, s13, s12
20001d60:	ece7 6a01 	vstmia	r7!, {s13}
                        osc_sinf(phase[11])) * 0.1f
                      );
                break;
        }
        *(y++) = f32_to_q31(sig);
        for (int i = 0; i < 12; i++) {
20001d64:	45bb      	cmp	fp, r7
20001d66:	d1ef      	bne.n	20001d48 <_hook_cycle+0x1c84>
            phase[i] += w0[i];
            phase[i] -= (uint32_t)phase[i];
        }
        lfoz += lfo_inc;
20001d68:	ee34 4a22 	vadd.f32	s8, s8, s5

    // yn = pointer to first buffer position
    q31_t * __restrict y = (q31_t *)yn; // pointer to current buffer position
    const q31_t * y_e = y + frames; // pointer to end of buffer

    for (; y < y_e; ) { //Loop to fill buffer (why is it not a while?)
20001d6c:	f7ff b8d0 	b.w	20000f10 <_hook_cycle+0xe4c>
            phase[i] -= (uint32_t)phase[i];
        }
        lfoz += lfo_inc;
    }
    for (int i = 0; i < 12; i++) {
        s_state.phase[i] = phase[i];
20001d70:	f856 2b04 	ldr.w	r2, [r6], #4
20001d74:	f845 2b04 	str.w	r2, [r5], #4
            phase[i] += w0[i];
            phase[i] -= (uint32_t)phase[i];
        }
        lfoz += lfo_inc;
    }
    for (int i = 0; i < 12; i++) {
20001d78:	45a9      	cmp	r9, r5
20001d7a:	d1f9      	bne.n	20001d70 <_hook_cycle+0x1cac>
        s_state.phase[i] = phase[i];
    }
    s_state.lfoz = lfoz;
20001d7c:	ed83 4a01 	vstr	s8, [r3, #4]
}
20001d80:	b01b      	add	sp, #108	; 0x6c
20001d82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
20001d86:	bf00      	nop
20001d88:	3d4ccccd 	.word	0x3d4ccccd

20001d8c <_hook_on>:
20001d8c:	4770      	bx	lr

20001d8e <_hook_off>:
{
    
}

void OSC_NOTEOFF(const user_osc_param_t * const params)
{
20001d8e:	4770      	bx	lr

20001d90 <_hook_param>:
    (void)params;
}

void OSC_PARAM(uint16_t index, uint16_t value)
{
    const float valf = param_val_to_f32(value);
20001d90:	ee07 1a90 	vmov	s15, r1
20001d94:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
20001d98:	eddf 7a1c 	vldr	s15, [pc, #112]	; 20001e0c <_hook_param+0x7c>
20001d9c:	ee67 7a27 	vmul.f32	s15, s14, s15
    // Parameters are from 0 to 1
    switch (index) {
20001da0:	2807      	cmp	r0, #7
20001da2:	d831      	bhi.n	20001e08 <_hook_param+0x78>
20001da4:	e8df f000 	tbb	[pc, r0]
20001da8:	30301304 	.word	0x30301304
20001dac:	261b3030 	.word	0x261b3030
        case k_user_osc_param_id1: //Wave type
            s_state.wave_type = (uint8_t)(value / 100.f * 3.f);
20001db0:	eddf 6a17 	vldr	s13, [pc, #92]	; 20001e10 <_hook_param+0x80>
20001db4:	4a17      	ldr	r2, [pc, #92]	; (20001e14 <_hook_param+0x84>)
20001db6:	eec7 7a26 	vdiv.f32	s15, s14, s13
20001dba:	eeb0 7a08 	vmov.f32	s14, #8	; 0x40400000  3.0
20001dbe:	ee67 7a87 	vmul.f32	s15, s15, s14
20001dc2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
20001dc6:	ee17 3a90 	vmov	r3, s15
20001dca:	7213      	strb	r3, [r2, #8]
            break;
20001dcc:	4770      	bx	lr
        case k_user_osc_param_id2: //Detune
            s_state.detune = 1023.f * valf;
20001dce:	ed9f 7a12 	vldr	s14, [pc, #72]	; 20001e18 <_hook_param+0x88>
20001dd2:	4b10      	ldr	r3, [pc, #64]	; (20001e14 <_hook_param+0x84>)
20001dd4:	ee67 7a87 	vmul.f32	s15, s15, s14
20001dd8:	edc3 7a1c 	vstr	s15, [r3, #112]	; 0x70
            break;
20001ddc:	4770      	bx	lr
        case k_user_osc_param_id5:
            break;
        case k_user_osc_param_id6:
            break;
        case k_user_osc_param_shape: //Key
            s_state.key = (uint8_t)(11.f * valf);
20001dde:	eeb2 7a06 	vmov.f32	s14, #38	; 0x41300000  11.0
20001de2:	ee67 7a87 	vmul.f32	s15, s15, s14
20001de6:	4a0b      	ldr	r2, [pc, #44]	; (20001e14 <_hook_param+0x84>)
20001de8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
20001dec:	ee17 3a90 	vmov	r3, s15
20001df0:	7293      	strb	r3, [r2, #10]
            break;
20001df2:	4770      	bx	lr
        case k_user_osc_param_shiftshape: //Extension
            s_state.extension = (uint8_t)(4.f * valf);
20001df4:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
20001df8:	ee67 7a87 	vmul.f32	s15, s15, s14
20001dfc:	4a05      	ldr	r2, [pc, #20]	; (20001e14 <_hook_param+0x84>)
20001dfe:	eefc 7ae7 	vcvt.u32.f32	s15, s15
20001e02:	ee17 3a90 	vmov	r3, s15
20001e06:	72d3      	strb	r3, [r2, #11]
20001e08:	4770      	bx	lr
20001e0a:	bf00      	nop
20001e0c:	3a802008 	.word	0x3a802008
20001e10:	42c80000 	.word	0x42c80000
20001e14:	20001ee0 	.word	0x20001ee0
20001e18:	447fc000 	.word	0x447fc000
